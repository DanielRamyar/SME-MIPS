In this section, we will be looking at pipelining our single cycle MIPS
processor, and handle the problems, which are introduced by pipelining.

We start by going through the background and motivation for pipelining, and
then proceed on how to extend our single cycle MIPS processor to have pipes.

As mentioned, pipelining introduces new problems to handle in the processor,
and we will solve it by adding two new components: the forwarding unit, which
forwards results from previous instructions to later instructions, and the
hazard detection unit, which controls when to stall the pipeline, and when the
instruction should read the forwarded value, or the value stored in the
Register File.

Throughout each step, we will also be writing programs, in order to verify that
our processor behaves as specified.

\subsection{Introducing the pipes}
We have the single cycle MIPS processor, which accepts the core integer
instruction set. However, it is not very efficient, as the clock rate of the
processor is determined by the longest possible path in the processor, so in
order to increase the clock rate, we must decrease the longest path in the
processor, which we solve with pipes.

Pipes are registers in the processor, where we temporarely store all the values
computed so far. It takes all of its inputs, and holds them until the next
clock tick, where it will forward the values it is holding. This ensures that
the data does not have to travel as far, until it have reached a safe (TODO:
find pÃ¥ et bedre ord end safe) state.

In order to know where to put the pipes, we divide the processor into stages.
We will use the same stages, as proposed in the book\cite{ref:ark}, i.e. divide
the processor into 5 stages: Instruction Fetch (IF), Instruction Decode (ID),
Execution (EX), Memory (MEM) and Write Back (WB). A simplified overview of the
processor and its stages can be seen in Figure \ref{fig:stages}. In between
each stage, we are going to insert a pipe, i.e. we are going to insert 4 pipes.
The simplified processor with pipes can be seen in figure \ref{fig:pipes}.

Introducing pipes also introduces additional problems, which we will discuss
further in sections \ref{sec:forw} and \ref{sec:haz}

\begin{figure}
    \centering
    \scalebox{0.5}{
        \begin{tikzpicture}
            \node[block] (alu) at (0,0) {ALU};
            \node[block] (reg) at (-4,0) {Register File};
            \node[block] (memo) at (4,0) {Memory};
            \node[block] (jump) at (4,4.75) {Jump};
            \node[block] (imem) at (-8,0) {Instruction Memory};
            \node[block] (pc) at (-9, 2) {PC};
            \node[control] (cont) at (-4, 3) {Control};
            \node[mux] (wbm) at (8,1) {|};

            \node[empty] (if) at (-8, 6) {\textbf{IF}};
            \node[empty] (id) at (-4, 6) {\textbf{ID}};
            \node[empty] (ex) at (0, 6) {\textbf{EX}};
            \node[empty] (mem) at (4, 6) {\textbf{MEM}};
            \node[empty] (wb) at (8, 6) {\textbf{WB}};

            \node[empty] (ifidt) at (-6,7) {};
            \node[empty] (idext) at (-2,7) {};
            \node[empty] (exmemt) at (2,7) {};
            \node[empty] (memwbt) at (6,7) {};
            \node[empty] (ifidb) at (-6,-3) {};
            \node[empty] (idexb) at (-2,-3) {};
            \node[empty] (exmemb) at (2,-3) {};
            \node[empty] (memwbb) at (6,-3) {};

            \path[draw, dashed, -] (ifidt) -- (ifidb);
            \path[draw, dashed, -] (idext) -- (idexb);
            \path[draw, dashed, -] (exmemt) -- (exmemb);
            \path[draw, dashed, -] (memwbt) -- (memwbb);

            \path[draw, ->] (pc) -| (imem);
            \path[draw, ->] (imem) -- (reg);
            \path[draw, ->] (-5.5,0) |- (cont);
            \path[draw, ->] (reg.15) -- (alu.151);
            \path[draw, ->] (reg.345) -- (alu.209);
            \path[draw, ->] (alu) -- (memo);
            \path[draw, ->] (-1,-0.31) -| (-1,-1) -- (2.5,-1) |- (memo.210);
            \path[draw, ->] (2.5, 0) |- (wbm.150);
            \path[draw, ->] (memo) -- (6.5, 0) |- (wbm.210);
            \path[draw, ->] (wbm) -| (9, -1.5) -| (reg);
            \path[draw, ->] (alu.30) -| (1,1) |- (4,2) -| (jump.290);
            \path[draw, ->] (jump) |- (0,5.5) -| (pc);
            \path[draw, ->] (-8,2) |- (jump.160);
            \path[draw, ->] (-5.5,3) |- (jump.200);

            \path[draw, color=blue, ->] (cont) -- (reg);
            \path[draw, color=blue, ->] (cont.330) -| (alu);
            \path[draw, color=blue, ->] (cont.350) -| (memo.115);
            \path[draw, color=blue, ->] (cont.10) -| (wbm);
            \path[draw, color=blue, ->] (cont.30) -| (jump.250);
        \end{tikzpicture}
    }
    \caption{The simplified single cycle processor, and its stages. The stage
    names are highlighted in \textbf{bold}. The stages are divided by dashed
    lines.}
    \label{fig:stages}
\end{figure}
\begin{figure}
    \centering
    \scalebox{0.5}{
        \begin{tikzpicture}
            \node[block] (alu) at (0,0) {ALU};
            \node[block] (reg) at (-4,0) {Register File};
            \node[block] (memo) at (4,0) {Memory};
            \node[block] (jump) at (4,4.75) {Jump};
            \node[block] (imem) at (-8,0) {Instruction Memory};
            \node[block] (pc) at (-9, 2) {PC};
            \node[control] (cont) at (-4, 3) {Control};
            \node[mux] (wbm) at (8,1) {|};

            \node[empty] (if) at (-8, 6) {\textbf{IF}};
            \node[empty] (id) at (-4, 6) {\textbf{ID}};
            \node[empty] (ex) at (0, 6) {\textbf{EX}};
            \node[empty] (mem) at (4, 6) {\textbf{MEM}};
            \node[empty] (wb) at (8, 6) {\textbf{WB}};

            \path[draw, ->] (pc) -| (imem);
            \path[draw, ->] (imem) -- (reg);
            \path[draw, ->] (-5.5,0) |- (cont);
            \path[draw, ->] (reg.15) -- (alu.151);
            \path[draw, ->] (reg.345) -- (alu.209);
            \path[draw, ->] (alu) -- (memo);
            \path[draw, ->] (-1,-0.31) -| (-1,-1) -- (2.5,-1) |- (memo.210);
            \path[draw, ->] (2.5, 0) |- (wbm.150);
            \path[draw, ->] (memo) -- (6.5, 0) |- (wbm.210);
            \path[draw, ->] (wbm) -| (9, -1.5) -| (reg.290);
            \path[draw, ->] (alu.30) -| (1,1) |- (4,2) -| (jump.290);
            \path[draw, ->] (jump) |- (0,5.5) -| (pc);
            \path[draw, ->] (-8,2) |- (jump.160);
            \path[draw, ->] (-5.5,3) |- (jump.200);

            \path[draw, color=blue, ->] (cont.310) -| (alu);
            \path[draw, color=blue, ->] (cont.330) -| (memo.115);
            \path[draw, color=blue, ->] (cont.350) -| (wbm);
            \path[draw, color=blue, ->] (cont.10) -| (9.5,-2) -| (reg.250);
            \path[draw, color=blue, ->] (cont.30) -| (jump.250);

            \node[block, minimum height=170, minimum width=10, fill=white] (ifid) at
            (-6,2.25) {};
            \node[block, minimum height=170, minimum width=10, fill=white] (idex) at
            (-2,2.25) {};
            \node[block, minimum height=180, minimum width=10, fill=white]
            (exmem) at (2,2) {};
            \node[block, minimum height=180, minimum width=10, fill=white]
            (exmem) at (6,2) {};
        \end{tikzpicture}
    }
    \caption{The simplified pipelined processor. The long bars in between each
    state is the pipes.}
    \label{fig:pipes}
\end{figure}

\subsubsection*{Implementation}
There are two ways to implement pipes in SME: by using clocked busses, or by
using clocked processes. If the bus only traverses 2 stages, then we can use
clocked busses, as the semantics of a clocked bus is exactly the same as a
pipe. However, if the bus traverses more than 2 stages, we are going to need
additional processes, as the clocked bus only stores its value for one clock.
Furthermore, if the only change to the bus is the given \texttt{ClockedBus}
attribute, then determining whether or not a bus is part of a pipe. As such, we
should have the pipe and its busses in its own class, as it then receives its
own prefix, and the code then becomes more readable.

Introducing the pipes in our processor is fairly straightforward, as we just
add 4 classes, each with the same set of busses as the 'previous' stage outputs
to the 'next' stage, and each with a register process, which forwards all the
values from the 'previous' stages busses, onto its own busses with the same
name.

Let us take a subset of the IF/ID pipe, as an example. We assume that each
state is in its own classes, i.e. \texttt{IF} and \texttt{ID}, and that the
\texttt{IF} stage has the \texttt{Instruction} bus, which the \texttt{ID} stage
reads from. Then, by adding a subclass to the \texttt{IF} stage, the name of
the bus that the \texttt{ID} class calls is converteted from
\texttt{IF.Instruction} to \texttt{IF.Pipe.Instruction}, emphasizing that the
bus is now piped.

Now, this process can be repeated for all of the required pipes. There is only
one really tricky part of pipelining: the Jump Unit. We dont know whether we
should jump until the \texttt{MEM} stage, as the computations are made in the
\texttt{EX} stage, and the conditions are computed in the \texttt{MEM} stage.
However, the Program Counter has to increment, regardless of whether or not we
should jump. As such, we should divide the Jump Unit into its subcomponents,
and place some of the logic in the \texttt{IF}, some in the \texttt{EX} stage
and finally some of it in the \texttt{MEM} stage.

For the \texttt{IF} stage, the incrementer and a multiplexor should be placed
inside the stage. The multiplexor should take an address computed from the
\texttt{MEM} stage, and the incremented Program Counter, and based on whether
or not the instruction that has reached the \texttt{MEM} stage was a branch or
jump instruction, it should choose the computed address.

The core computation of the jump and branch instructions should be placed in
the \texttt{EX} stage. As such, the \texttt{EX} stage should compute both the
branch address and the jump address.

Finally, the \texttt{MEM} stage should hold the decision logic. First, it
should determine if the instruction was an branch instruction, and whether or
not the condition has been satisfied, in which case, the  address forwarded to
the \texttt{IF} stage should be the branch address. If this was not the case,
the computed jump address should be the one forwarded.

Finally, in the single cycle MIPS processor, we introduced the Write Buffer, in
order to remove the cycle from and to the Register File. However, by
introducing pipes, we have introduced a new buffer, and thus the Write Buffer
can be removed.

\subsubsection*{Testing}
To test the processor, we can use any of the programs, that we have previously
written. However, since we have pipelined the processor, we need to insert
bubbles, in order for data to be available for each instruction. A bubble is a
No Operation (\texttt{nop}) instruction, which performs no operation, and does
not modify neither the Register File nor the Memory.

We are going to implement a simple program, which is easy to verify: a small
loop, which computes $n$Â fibonacci numbers, and places them in memory. As with
the simple cycle, we are going to give pseudo low level C code:
\begin{lstlisting}
void init(int *arr) {
    *(arr)   = 1;
    *(arr+1) = 1;
}

void loop(int *arr, int n) {
    int i, tmp1, tmp2, tmp3;
    for (i = 0; i < n; i++) {
        tmp1 = *(arr+i);
        tmp2 = *(arr+i+1);
        tmp3 = tmp1 + tmp2;
        *(arr+i+2) = tmp3;
    }
}
\end{lstlisting}
Note that for verification in C, the array should be $n+2$, due to
initialization. Furthermore, when we port it to MIPS assembly, after each
instruction, we should insert 4 \texttt{nop}'s, to ensure the data is ready for
the next instruction. When the program has run, the $n+2$ fibonacci numbers
should be in memory, at the given address.

\subsection{Forwarding}\label{sec:forw}
By introducing pipes, we also introduced data hazards and control hazards. We
will go through control hazards in section \ref{sec:haz}. Data hazards are when
one instruction writes to a register, that a following instruction reads from.
This is not a problem in the single cycle processor, as all data have been
written to registers in the same clock cycle. This is not the case in the
pipelined processor, e.g. the data might reside in the MEM stage, when it is
needed in the EX stage.

We can eliminate some of the data hazards by implementing an additional unit:
the Forwarding Unit. The rest of the data hazards will be handled by hazard
detection in section \ref{sec:haz}. The Forwarding Unit looks at the register
addresses used by the instruction in the EX stage, and checks if it corresponds
with the register write address of either the instruction in the MEM stage, or
the instruction in the WB stage. If they correspond, it forwards the value from
either the MEM or the WB stage to the EX stage.

\subsubsection*{Implementation}
Implementing the Forwarding Unit should be done with an SME process. As it
interferes with the EX stage, it should be put in the EX stage. The unit should
be controlling two multiplexors. The first multiplexor should control whether
Output A should come from the ID pipe, the write data from the MEM stage or the
write data from the WB stage. The other multiplexor is analogous, but with
Output B. The two multiplexors should be controlled by the Forwarding Unit,
i.e. it should generate the control signals for the multiplexors based on the
two register read addresses of the current instruction in the EX stage, the
register write address and write enabled signal both from the MEM and the WB
stages.

\subsubsection*{Testing}
Testing is straightforward: we can just remove all of the \texttt{nop}'s from
the fibonacci program, except for those which come after either a load, a
branch or a jump, as these hazards are not handled yet.

\subsection{Hazard Detection}\label{sec:haz}
As mentioned in section \ref{sec:forw}, we cannot avoid all data hazards with
forwarding. This is due to forwarding only forwarding to the EX stage. However,
if the instruction prior to the instruction in EX is a load, then the data wont
be available, until the load instruction has reached the WB stage. To handle
this, the processor needs to detect the hazard and insert a bubble, as this
will delay the instruction, so that when it has reached the EX stage, the load
instruction will be in the WB stage. When inserting a bubble in the middle of
the pipeline, we have to stall some of the pipes and registers. Stalling is the
action of outputting what is stored in the register, but not updating it, i.e.
outputting the same data in the next clock cycle.

We also need to be able to handle an additional type of hazard: control
hazards. Control hazards are when either jump or branch instructions are
executed. The problem is that the branch or jump is not performed until the MEM
stage, which means that the pipeline following the jump or branch instruction
may have been filled up by instructions, which should not be executed. To solve
this, we should detect the hazard, and in such case flush the pipeline.
Flushing the pipeline, is the action of resetting the registers in the pipes,
so that they output a \texttt{nop} instruction.

\subsubsection*{Implementation}
The hazard detection should be implemented in its own SME process: the Hazard
Detection Unit.

To solve the data hazards, it needs to read the \texttt{memread} control flag
from the EX stage, the register write address from the EX stage and the two
source register addresses from the ID stage. If the \texttt{memread} flag has
been set, and either of the source registers match the destination register,
then the ID/EX pipe should be flushed, the IF/ID pipe should be stalled, and
the PC register should be stalled.

To solve the control hazards, it should read the \texttt{PCSrc} flag from the
MEM stage (the one used by the PC register, to multiplex between the
incremented address, and the jump/branch address), and if it is set, then the
IF/ID, ID/EX and EX/MEM pipes should be flushed. Note: the PC register should
read normally in the case of a flush, even though it might have to stall, as
the stall is detected in the to be flushed part of the pipeline.

\subsubsection*{Testing}
Testing the new hazard detection is straightforward, as the processor should
now be able to handle all of the previous programs, albeit in a larger amount
of clock ticks, compared to the single cycle processor.

Note: if these programs are tested against the single cycle processor, the
performance will be worse, when simulating. This is due to more processes and
busses, which gives the simulation more work. There should not be any
performance hit, when the processor is run on hardware.

\subsection{Branch prediction?} PERFORMANCE HIT! nÃ¦vn at det sker i simulering
TODO

fÃ¥ noget ala linux til at kÃ¸re?

scratchpad memory som agere cache?

flere kerner?

scalar processor?



