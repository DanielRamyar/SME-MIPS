In this section, we will be looking at the major components of the MIPS
processor. For each component, we will go through the theory of the component,
then we will look at translating theory into an SME implementation, and the
verification of the implementations. The order in which the components are
mentioned, is the order of implementation.

By the end of this section, we should have all of the required resources for
building our single cycle MIPS processor using SME.

\subsection{Register file}
The Register File is the component that holds values for the processor. It is
the first step in a memory hierarchy, and is thus the fastest memory available.
There are 32 registers in a 32-bit MIPS processor. The registers are divided
into groups based on their usage. This does not matter from a hardware
perspective, except for register 0, which is immutable and always 0.

The Register File has 5 inputs: Read Address A, Read Address B, Write Enabled,
Write Address and Write Data. It also has two outputs: Output A and Output B.
It has two stages: reading and writing. In the reading stage, it takes the
value in the register at the address of Read Address A, and outputs it on
Output B, and vice versa for Read Address B and Output B. In the writing stage,
if the Write Enabled flag is set, it takes the value from the Write Data, and
stores it in the register with the address in Write Address.

We need to be careful of the order in which we read and write from the Register
File. We need to make sure that when an instruction reads from the Register
File, it always gets the latest data, i.e. if an instruction reads from the
same register as a previous instruction writes to, it should get the newly
written value. This is easy to fix in the single cycle processor, as we just
need to write before reading. The Register File and its inputs and outputs can
be seen in Figure \ref{fig:register}.

\begin{figure}
    \centering
    \begin{tikzpicture}[node distance=2cm]
        \node[empty] (inputa) {Input A};
        \node[empty, below of=inputa] (inputb) {InputB};

        \node[empty, right of=inputa] (spacing) at ($(inputa)!0.5!(inputb)$) {};
        \node[block, right of=spacing] (register) {Register};
        \node[empty, below of=register] (writedata) {Write data};
        \node[empty, left of=writedata] (write) {Write register};
        \node[empty, right of=writedata] (writeenabled) {Write enabled};

        \node[empty, right of=inputa] (space) {};
        \node[empty, right of=space] (spacee) {};
        \node[empty, right of=spacee] (spaceee) {};
        \node[empty, right of=spaceee] (outputa) {Output A};
        \node[empty, below of=outputa] (outputb) {Output B};
        \node[empty, left of=outputb] (bspace) {};

        \path[draw, -] (inputa) -| (spacing.north);
        \path[draw, ->] (spacing.north) |- (register.155);
        \path[draw, -] (inputb) -| (spacing.south);
        \path[draw, ->] (spacing.south) |- (register.205);

        \path[draw, -] (write) |- (writedata.135);
        \path[draw, ->] (writedata.135) -- (register.225);
        \path[draw, ->] (writedata) -- (register);
        \path[draw, -] (writeenabled) |- (writedata.45);
        \path[draw, ->] (writedata.45) -- (register.315);

        \path[draw, -] (register.335) -| (bspace.north);
        \path[draw, ->] (bspace.north) |- (outputb);
        \path[draw, -] (register.25) -| (spaceee.south);
        \path[draw, ->] (spaceee.south) |- (outputa);
    \end{tikzpicture}
    \caption{The register file}
    \label{fig:register}
\end{figure}

\subsubsection*{Implementation}
The implementation of the register file in SME is done by the use of an
\texttt{int} array. We construct a process, that when all of its inputs are
ready, it takes the write input, and stores it in the array with the given
index, if it is greater than 0, and if the \texttt{RegWrite} flag has been set.
In case we do get a 0, we just ignore the request, as this is usually the
pattern of a \texttt{nop} instruction.

After the process have written to the register, it processes the read
addresses, and outputs the values stored in the array at the given addresses.

\subsubsection*{Testing}
Testing the register file is very trivial. We start by sending some values
on the write data bus, along with some addresses and the \texttt{RegWrite}
flag set.

Then we just try to send some addresses on the Read address A and Read
address B buses, and verify that the register file outputs the values
stored at these addresses. It is also important to verify the behaviour of
register zero.

\subsection{ALU}
The ALU (Arithmetic Logic Unit) is the part of the processor, which makes the
actual computation. It takes three inputs: InputA, InputB and an ALU Opcode
indicating which computation to perform. It has two outputs: The result of the
computation, and a zero flag indicating whether or not the result of the
computation was 0. The overview of the component and its inputs and outputs can
be seen in Figure \ref{fig:alu}.

The ALU starts by looking at the value in the ALU Opcode, as this determines
which operation to perform. Then it reads the values from Input A and Input B,
and performs the operation specified by the ALU Opcode. Finally, it outputs the
result, and a flag indicating whether the result was 0.

\begin{figure}
    \centering
    \begin{tikzpicture} [node distance=1.5cm]
        \node[empty] (ina) {Input A};
        \node[empty, below of=ina] (inb) {Input B};
        \node[empty, right of=inputa] (spacing) at ($(ina)!0.5!(inb)$) {};
        \node[block, right of=spacing] (alu) {ALU};
        \node[empty, right of=ina] (align0) {};
        \node[empty, right of=align0] (align1) {};
        \node[empty, right of=align1] (align2) {};
        \node[empty, right of=align2] (result) {Zero};
        \node[empty, below of=result] (zero) {Result};
        \node[empty, left of=zero] (align3) {};
        \node[empty, below of=alu] (aluop) {ALUOp};

        \path[draw, -] (ina.east) -| (spacing.155);
        \path[draw, ->] (spacing.155) -- (alu.155);
        \path[draw, -] (inb.east) -| (spacing.205);
        \path[draw, ->] (spacing.205) -- (alu.205);
        \path[draw, ->] (aluop) -- (alu);
        \path[draw, -] (alu.25) -| (align2.east);
        \path[draw, ->] (align2.east) -- (result);
        \path[draw, -] (alu.335) -| (align3.east);
        \path[draw, ->] (align3.east) -- (zero);
    \end{tikzpicture}
    \caption{The ALU}
    \label{fig:alu}
\end{figure}

\subsubsection*{Implementation}
To implement the ALU, we start by making an \tt{enum}, so that the code becomes
more human readable. Each entry in the \tt{enum} corresponds to a computation
that the ALU should perform. We start by implementing the same instructions as
the book proposes:  % TODO ref!
\texttt{add}, \texttt{sub}, \texttt{and}, \texttt{or}, \texttt{slt},
\texttt{sw}, \texttt{lw} and \texttt{beq}.  To perform these instructions, the
ALU should be able to perform addition, subtraction, logical \tt{AND}, logical
\tt{OR} and the comparison less than.

Constructing the ALU process in SME is straightforward, it reads from the ALUOp
bus, and then it performs a \texttt{switch} on the ALU Opcode. For the
instructions that it accepts, it takes the input from the two input busses, do
the computation, and output the result on the Result bus. Finally, the ALU
should set the flag on the zero bus, whether or not the computation was 0. How
the ALU opcode is encoded is described in Section \ref{sec:alu-control}.

\subsubsection*{Testing}
Testing the ALU is like the Register File, very trivial. Construct a tester
process, which sends values on the Input A, Input B and ALU Opcode busses,
reads the values from the Result and Zero busses, and verify that the values
are as expected.

\subsection{Control Unit}
\label{sec:control-unit}
The control unit is part of the decoding step. It takes the opcode of the
instruction, and based on the opcode, it sets control flags used throughout the
processor. It sets the following control flags:
\begin{description}
    \item[RegDst]Â Controls which part of the instruction that indicates which
        B register to read from.

    \item[Branch] Controls whether or not the instruction is a branch
        instruction.

    \item[MemRead] Controls whether or not there should be read from memory.

    \item[MemtoReg] Controls whether or not the value from memory should be
        stored in the register file.

    \item[ALUOp] Opcode indicating which operation should be performed in
        the ALU. It is send to the ALU Control for further processing.

    \item[MemWrite] Controls whether or not data should be written to memory.

    \item[ALUSrc] Controls whether the B input for the ALU should be the
        value read from the register file, or if it should be the value
        extracted from the instruction.

    \item[RegWrite] Controls whether or not data should be written to the
        register file.
\end{description}
Each of the control flags goes to their respective part of the processor.
We will return to this component, when we have to extend it to handle more
instructions. The control unit can be seen in Figure \ref{fig:cont-unit}
\begin{figure}
    \centering
    \begin{tikzpicture}
        \node[control] (cont)   at (0,  0)   {Control Unit};
        \node[empty] (opcode)   at (-3, 0)   {Opcode};
        \node[empty] (branch)   at (4,  1.75) {\texttt{Branch}};
        \node[empty] (regwrite) at (4,  1.25) {\texttt{RegWrite}};
        \node[empty] (memtoreg) at (4,  0.75) {\texttt{MemToReg}};
        \node[empty] (memwrite) at (4,  0.25) {\texttt{MemWrite}};
        \node[empty] (memread)  at (4, -0.25) {\texttt{MemRead}};
        \node[empty] (alusrc)   at (4, -0.75) {\texttt{ALUSrc}};
        \node[empty] (aluop)    at (4, -1.25) {\texttt{ALUOp}};
        \node[empty] (regdst)   at (4, -1.75) {\texttt{RegDst}};

        \path[draw, ->] (opcode) -- (cont);

        \path[draw, ->, color=blue] (cont.35)  -| (2,1.5) |- (branch);
        \path[draw, ->, color=blue] (cont.25)  -| (2.25,1) |- (regwrite);
        \path[draw, ->, color=blue] (cont.15)  -| (2.5,0.5) |- (memtoreg);
        \path[draw, ->, color=blue] (cont.5)   -| (2.75,0.125) |- (memwrite);
        \path[draw, ->, color=blue] (cont.355) -| (2.75,-0.125) |- (memread);
        \path[draw, ->, color=blue] (cont.345) -| (2.5,-0.5) |- (alusrc);
        \path[draw, ->, color=blue] (cont.335) -| (2.25,-1) |- (aluop);
        \path[draw, ->, color=blue] (cont.325) -| (2,-1.5) |- (regdst);
    \end{tikzpicture}
    \caption{The Control Unit}
    \label{fig:cont-unit}
\end{figure}

\subsubsection*{Implementation \& Testing}
The book describes the logic needed to implement this unit. However, it only
describes the logic for the before mentioned instructions, and is therefore
hard to extend. Therefore, we start by making an extendable Control Unit.

As with the ALU, start by having an \texttt{enum} for both the opcode and the
ALUOp. Then the process should \texttt{switch}Â on the opcode, and set the flags
accordingly. This way, adding more instructions is just adding entries in the
\texttt{enum}s, and adding cases to the \texttt{switch}, and then it is up to
the VHDL generator to construct the logic.

As with the Register File and the ALU, we test the Control Unit, by having a
tester process, which sends input, and verifies the output values.

\subsection{ALU control}\label{sec:alu-control}
The ALU control is used for generating the ALU Operation control code, which
the ALU uses for selecting which operation to perform. It takes two inputs: the
\texttt{ALUOp} code from the control unit, and the \texttt{funct} code from the
instruction, and it computes its output based on these. The ALU Control can be
seen in Figure \ref{fig:alu-cont}
\begin{figure}
    \centering
    \begin{tikzpicture}
        \node[block] (alucont) at (0,0) {ALU Control};
        \node[empty] (aluop) at (-3, 0.4) {ALUOp};
        \node[empty] (funct) at (-3, -0.4) {Funct};
        \node[empty] (aluope) at (0, 2) {ALU Operation};

        \path[draw, ->] (aluop) -- (alucont.161);
        \path[draw, ->] (funct) -- (alucont.199);
        \path[draw, ->] (alucont) -- (aluope);
    \end{tikzpicture}
    \caption{The ALU Control}
    \label{fig:alu-cont}
\end{figure}

If the \texttt{ALUOp} from the control unit indicates that the instruction is
an R format instruction, it uses the \texttt{funct} code for selecting the
operation.  Otherwise it bases its output purely on the \texttt{ALUOp}Â code. As
before, we will return to this component, when we need to extend the
instruction set.

\subsubsection*{Implementation \& Testing}
As with the main Control Unit, the book describes usable logic, but it does not
correspond to our own ALUOp from the Control Unit, or the needed ALU Operation
codes for the ALU. As such, we should do the same as in the Control Unit. We
start by checking whether or not the opcode from the instruction indicates that
the instruction is an R-format. If this is the case, we need to \texttt{switch}
on the \texttt{funct} field of the instuction, otherwise \texttt{switch} on the
opcode from the ALUOp.

It is tested in the same manner as the Control Unit.

\subsection{Splitter}
This is a very simple component, but it is still used in the decoding step of
the processor. It takes the instruction, which has been fetched from memory,
and divides it into chunks for the different parts of the decoding. The
instruction is partitioned as followed (the bits are inclusive):
\begin{itemize}
    \item Opcode - bits 26-31
    \item Read Address A - bits 21-25
    \item Read Address B - bits 16-20
    \item Write Address - bits 11-15
    \item Immediate - bits 0-15
    \item Funct - bits 0-5
\end{itemize}
The Splitter can be seen in Figure \ref{fig:split}
\begin{figure}
    \centering
    \begin{tikzpicture}
        \node[block] (split) at (0,0) {Splitter};
        \node[empty] (inst) at (-3,0) {Instruction};
        \node[empty] (op) at (4,1.25) {Opcode};
        \node[empty] (ra) at (4,0.75) {Read Address A};
        \node[empty] (rb) at (4,0.25) {Read Address B};
        \node[empty] (wa) at (4,-0.25) {Write Address};
        \node[empty] (imm) at (4,-0.75) {Immediate};
        \node[empty] (fun) at (4,-1.25) {Funct};

        \path[draw, ->] (inst) -- (split);
        \path[draw, ->] (split.25) -| (1.5, 1) |- (op);
        \path[draw, ->] (split.15) -| (1.75,0.5) |- (ra);
        \path[draw, ->] (split.5) -| (2,0.125) |- (rb);
        \path[draw, ->] (split.355) -| (2,-0.125) |- (wa);
        \path[draw, ->] (split.345) -| (1.75,-0.5) |- (imm);
        \path[draw, ->] (split.335) -| (1.5, -1) |- (fun);
    \end{tikzpicture}
    \caption{The Splitter}
    \label{fig:split}
\end{figure}

\subsubsection*{Implementation \& Testing}
The implementation is straightforward: We take the instruction comming from the
instruction fetch part of the processor, and extract the bits at the indices,
by using C\# bit hacking. Finally, output the extracted values on the
respective output busses.

As before, testing is performed by constructing a tester process, which sends
input, and verifies the output.

\subsection{Sign Extend}
The Sign Extend is used for extracting values from the instruction. It takes
its input, which is 16-bit, and converts it into a 32-bit value, extending the
sign if present. The Sign Extend can be seen in Figure \ref{fig:sign}
\begin{figure}
    \centering
    \begin{tikzpicture}
        \node[block] (sign) at (0,0) {Sign Extend};
        \node[empty] (imm) at (-3,0) {Immediate};
        \node[empty] (immout) at (4,0) {Sign extended immediate};

        \path[draw, ->] (imm) -- (sign);
        \path[draw, ->] (sign) -- (immout);
    \end{tikzpicture}
    \caption{The Sign Extend}
    \label{fig:sign}
\end{figure}

\subsubsection*{Implementation \& Testing}
The SME proces takes the 16-bit immediate, and outputs it on its 32-bit output
bus. C\# handles the sign extension for us.

It is tested in the same manner as the previous components.

\subsection{Instruction Memory}
The Instruction Memory is the part of the processor, which holds the program.
It has a chunk of memory, and for each clock, it outputs the value at the given
address. It has one input, the program counter (PC), and one output, the read
instruction. The Instruction Memory can be seen in Figure \ref{fig:inst}
\begin{figure}
    \centering
    \begin{tikzpicture}
        \node[block] (inmem) at (0,0) {Instruction Memory};
        \node[empty] (pc) at (-2, 2) {PC};
        \node[empty] (inst) at (4,0) {Instruction};

        \path[draw, ->] (pc) -| (inmem);
        \path[draw, ->] (inmem) -- (inst);
    \end{tikzpicture}
    \caption{The Instruction Memory}
    \label{fig:inst}
\end{figure}

\subsubsection*{Implementation \& Testing}
Upon receiving all of its inputs, the SME process should read the address from
the PC bus, and output the value stored in the memory at the read
address.

Usually the memory should be a \texttt{byte} array. However, since we are
working with C\#, we can just use a \texttt{int} array for simplicity, as we do
not have to worry about word alignment.

The Instruction Memory is tested in the same manner as the previous components.

\subsection{Memory unit}
The memory unit is the main memory. The CPU can either read or write to the
memory unit. The addresses for the memory are word sized, i.e. in the 32-bit
processor, the word size is 32 bit. The Memory Unit has four inputs: Address,
Data, \texttt{MemRead} and \texttt{MemWrite}. It has a single output: Read
Data. In one clock, the Memory Unit either reads or writes. The Memory Unit can
be seen in Figure \ref{fig:mem}
\begin{figure}
    \centering
    \begin{tikzpicture}
        \node[block] (mem) at (0,0) {Memory};
        \node[empty] (addr) at (-3,0.4) {Address};
        \node[empty] (data) at (-3,-0.4) {Data};
        \node[empty] (memread) at (-1.5, 1) {\texttt{MemRead}};
        \node[empty] (memwrite) at (1.5, 1) {\texttt{MemWrite}};
        \node[empty] (readdata) at (3, 0) {Read Data};

        \path[draw, ->] (addr) -- (mem.154);
        \path[draw, ->] (data) -- (mem.206);
        \path[draw, ->] (memread) -| (mem.110);
        \path[draw, ->] (memwrite) -| (mem.70);
        \path[draw, ->] (mem) -- (readdata);
    \end{tikzpicture}
    \caption{The Memory Unit}
    \label{fig:mem}
\end{figure}

\subsubsection*{Implementation \& Testing}
As with the Instruction Memory, we are going to need a chunk of memory.
However, this time we do want to construct it using a \texttt{byte} array, as
later programs expect this. As such, the SME process needs to pack four bytes
into an \texttt{int} value.

In each clock, the process should check if the \texttt{MemRead} flag is set, in
which case it should read the value on the Address bus, and output the value
stored in memory at the read address. Then it should check if the
\texttt{MemWrite} flag is set, in which case it should read the value at the
Address bus and the Data bus, store the read data in memory at the read
address.

The Memory Unit is tested in the same manner as the Register File.

\subsection{Jump Unit}
The Jump Unit is the one controlling which instruction to load next. It takes
four inputs: sign extend, Zero, \texttt{beq} and the PC. It
produces one output: the new PC. The Jump Unit and its connections
can be seen in Figure \ref{fig:jump}
\begin{figure}
    \centering
    \begin{tikzpicture}
        \node[block] (and) at (0,0) {\texttt{AND}};
        \node[block] (inc) at (-2,1) {+4};
        \node[block] (add) at (2,1) {+};
        \node[empty] (pc) at (-4,1) {PC};
        \node[empty] (beq) at (-0.5,-1.5) {\texttt{beq}};
        \node[empty] (zero) at (0.5,-1.5) {Zero};
        \node[empty] (imm) at (4,1) {Immediate};
        \node[empty] (out) at (-4,2) {New PC};
        \node[mux] (mux) at (0,2) {|};

        \path[draw, ->, color=blue] (beq.65) -- (and.245);
        \path[draw, ->, color=blue] (zero.115) -- (and.295);
        \path[draw, ->, color=blue] (and) -- (mux);
        \path[draw, ->] (pc) -- (inc);
        \path[draw, ->] (inc) -- (add);
        \path[draw, ->] (imm) -- (add);
        \path[draw, ->] (add.north) |- (mux.45);
        \path[draw, ->] (1, 1) |- (mux.315);
        \path[draw, ->] (mux) -- (out);

        \draw (-2.8,-0.8) rectangle (2.8,2.8);
    \end{tikzpicture}
    \caption{The Jump Unit}
    \label{fig:jump}
\end{figure}

For the simple single cycle MIPS processor, it should only have support for
normal program traversal (i.e. execute the instructions in order) and the
\texttt{beq} instruction. We will be adding support for more branch and jump
instructions later.

\subsubsection*{Implementation \& Testing}
The book describes the logic for both of the initial requirements. To add the
normal program traversel, the Jump Unit should take the input PC, and increment
it by 4, such that it points to the next instruction. To add support for
branching, it should take the incremented PC, and add it with the sign extended
immediate. The \texttt{beq} signal and the Zero signal should go to an
\texttt{AND} gate, which should be a control signal for a multiplexor. The
incremented PC, and the PC with the added immediate should go into inputs for
the mux. If the control signal into the multiplexor is \texttt{0}, then the
incremented PC should be the output, otherwise the PC with the added immediate.
The output from the multiplexor should also be the output for the Jump Unit.

The testing is performed in the same manner as with the other components.

\subsection{Write back}
The final stage of the processor is the Write Back. Here, the values are sent
to the Register File for storing.

\subsubsection*{Implementation \& Testing}
Usually in the single cycle MIPS processor, there is nothing special in the
Write Back. However, in SME we are not allowed to have unclocked cycles, and
there is a cycle from the Register File, through the ALU and the Memory Unit,
and back to the Register File.

To solve this, we introduce a Write Buffer. The write buffer takes the Write
Data, Write Register and \texttt{WriteEnabled}Â as input, and produces the same
output. On each clock, it should output its stored values, and store its input
values. The Write Buffer can be seen in Figure \ref{fig:wb}
\begin{figure}
    \centering
    \begin{tikzpicture}
        \node[block] (wb) at (0,0) {Write Buffer};
        \node[empty] (wr) at (0,2) {Write Register};
        \node[empty] (wd) at (3,0.5) {Write Data};
        \node[empty] (rw) at (3,-0.5) {\texttt{RegWrite}};
        \node[empty] (wr2) at (-3, 0.5) {Write Register};
        \node[empty] (wd2) at (-3, 0) {Write Data};
        \node[empty] (rw2) at (-3, -0.5) {\texttt{RegWrite}};

        \path[draw, ->] (wr) -- (wb);
        \path[draw, ->] (wd) -| (1.35, 0.45) |- (wb.20);
        \path[draw, ->] (rw) -| (1.35, -0.45) |- (wb.340);
        \path[draw, ->] (wb) -- (wd2);
        \path[draw, ->] (wb.160) -| (-1.35,0.45) |- (wr2);
        \path[draw, ->] (wb.200) -| (-1.35,-0.45) |- (rw2);
    \end{tikzpicture}
    \caption{The Write Buffer}
    \label{fig:wb}
\end{figure}

Testing is performed in the same manner as the previous components.
