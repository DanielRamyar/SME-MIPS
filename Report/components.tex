In this section, we will be looking at the major components of the MIPS
processor. For each component, we will go through the theory of the component,
then we will look at translating theory into an SME implementation, and the
verification of the implementations. The order in which the components are
mentioned, is the order of implementation.

By the end of this section, we should have all of the required resources for
building our single cycle MIPS processor using SME.

\subsection{Register file}
The Register File is the component that holds values for the processor. It is
the first step in a memory hierarchy, and is thus the fastest memory available.
There are 32 registers in a 32-bit MIPS processor. The registers are divided
into groups based on their usage. This does not matter from a hardware
perspective, except for register 0, which is immutable and always 0.

The Register File has 5 inputs: Read Address A, Read Address B, Write Enabled,
Write Address and Write Data. It also has two outputs: Output A and Output B.
It has two stages: reading and writing. In the reading stage, it takes the
value in the register at the address of Read Address A, and outputs it on
Output B, and vice versa for Read Address B and Output B. In the writing stage,
if the Write Enabled flag is set, it takes the value from the Write Data, and
stores it in the register with the address in Write Address.

We need to be careful of the order in which we read and write from the Register
File. We need to make sure that when an instruction reads from the Register
File, it always gets the latest data, i.e. if an instruction reads from the
same register as a previous instruction writes to, it should get the newly
written value. This is easy to fix in the single cycle processor, as we just
need to write before reading. The Register File and its inputs and outputs can
be seen in Figure \ref{fig:register}.

\begin{figure}
    \centering
    \begin{tikzpicture}[node distance=2cm]
        \node[empty] (inputa) {Input A};
        \node[empty, below of=inputa] (inputb) {InputB};

        \node[empty, right of=inputa] (spacing) at ($(inputa)!0.5!(inputb)$) {};
        \node[block, right of=spacing] (register) {Register};
        \node[empty, below of=register] (writedata) {Write data};
        \node[empty, left of=writedata] (write) {Write register};
        \node[empty, right of=writedata] (writeenabled) {Write enabled};

        \node[empty, right of=inputa] (space) {};
        \node[empty, right of=space] (spacee) {};
        \node[empty, right of=spacee] (spaceee) {};
        \node[empty, right of=spaceee] (outputa) {Output A};
        \node[empty, below of=outputa] (outputb) {Output B};
        \node[empty, left of=outputb] (bspace) {};

        \path[draw, -] (inputa) -| (spacing.north);
        \path[draw, ->] (spacing.north) |- (register.155);
        \path[draw, -] (inputb) -| (spacing.south);
        \path[draw, ->] (spacing.south) |- (register.205);

        \path[draw, -] (write) |- (writedata.135);
        \path[draw, ->] (writedata.135) -- (register.225);
        \path[draw, ->] (writedata) -- (register);
        \path[draw, -] (writeenabled) |- (writedata.45);
        \path[draw, ->] (writedata.45) -- (register.315);

        \path[draw, -] (register.335) -| (bspace.north);
        \path[draw, ->] (bspace.north) |- (outputb);
        \path[draw, -] (register.25) -| (spaceee.south);
        \path[draw, ->] (spaceee.south) |- (outputa);
    \end{tikzpicture}
    \caption{The register file}
    \label{fig:register}
\end{figure}

\subsubsection*{Implementation}
The implementation of the register file in SME is done by the use of an
\texttt{int} array. We construct a process, that when all of its inputs are
ready, it takes the write input, and stores it in the array with the given
index, if it is greater than 0, and if the \texttt{RegWrite} flag has been set.
In case we do get a 0, we just ignore the request, as this is usually the
pattern of a \texttt{nop} instruction.

After the process have written to the register, it processes the read
addresses, and outputs the values stored in the array at the given addresses.

\subsubsection*{Testing}
Testing the register file is very trivial. We start by sending some values
on the write data bus, along with some addresses and the \texttt{RegWrite}
flag set.

Then we just try to send some addresses on the Read address A and Read
address B buses, and verify that the register file outputs the values
stored at these addresses. It is also important to verify the behaviour of
register zero.

\subsection{ALU}
The ALU (Arithmetic Logic Unit) is the part of the processor, which makes the
actual computation. It takes three inputs: InputA, InputB and an ALU Opcode
indicating which computation to perform. It has two outputs: The result of the
computation, and a zero flag indicating whether or not the result of the
computation was 0. The overview of the component and its inputs and outputs can
be seen in Figure \ref{fig:alu}.

The ALU starts by looking at the value in the ALU Opcode, as this determines
which operation to perform. Then it reads the values from Input A and Input B,
and performs the operation specified by the ALU Opcode. Finally, it outputs the
result, and a flag indicating whether the result was 0.

\begin{figure}
    \centering
    \begin{tikzpicture} [node distance=1.5cm]
        \node[empty] (ina) {Input A};
        \node[empty, below of=ina] (inb) {Input B};
        \node[empty, right of=inputa] (spacing) at ($(ina)!0.5!(inb)$) {};
        \node[block, right of=spacing] (alu) {ALU};
        \node[empty, right of=ina] (align0) {};
        \node[empty, right of=align0] (align1) {};
        \node[empty, right of=align1] (align2) {};
        \node[empty, right of=align2] (result) {Zero};
        \node[empty, below of=result] (zero) {Result};
        \node[empty, left of=zero] (align3) {};
        \node[empty, below of=alu] (aluop) {ALUOp};

        \path[draw, -] (ina.east) -| (spacing.155);
        \path[draw, ->] (spacing.155) -- (alu.155);
        \path[draw, -] (inb.east) -| (spacing.205);
        \path[draw, ->] (spacing.205) -- (alu.205);
        \path[draw, ->] (aluop) -- (alu);
        \path[draw, -] (alu.25) -| (align2.east);
        \path[draw, ->] (align2.east) -- (result);
        \path[draw, -] (alu.335) -| (align3.east);
        \path[draw, ->] (align3.east) -- (zero);
    \end{tikzpicture}
    \caption{The ALU}
    \label{fig:alu}
\end{figure}

\subsubsection*{Implementation}
To implement the ALU, we start by making an \tt{enum}, so that the code becomes
more human readable. Each entry in the \tt{enum} corresponds to a computation
that the ALU should perform. We start by implementing the same instructions as
the book proposes:  % TODO ref!
\texttt{add}, \texttt{sub}, \texttt{and}, \texttt{or}, \texttt{slt},
\texttt{sw}, \texttt{lw} and \texttt{beq}.  To perform these instructions, the
ALU should be able to perform addition, subtraction, logical \tt{AND}, logical
\tt{OR} and the comparison less than.

Constructing the ALU process in SME is straightforward, it reads from the ALUOp
bus, and then it performs a \texttt{switch} on the ALU Opcode. For the
instructions that it accepts, it takes the input from the two input busses, do
the computation, and output the result on the Result bus. Finally, the ALU
should set the flag on the zero bus, whether or not the computation was 0. How
the ALU opcode is encoded is described in Section \ref{sec:alu-control}.

\subsubsection*{Testing}
Testing the ALU is like the Register File, very trivial. Construct a tester
process, which sends values on the Input A, Input B and ALU Opcode busses,
reads the values from the Result and Zero busses, and verify that the values
are as expected.

\subsection{Control Unit}
\label{sec:control-unit}
The control unit is part of the decoding step. It takes the opcode of the
instruction, and based on the opcode, it sets control flags used throughout the
processor. It sets the following control flags:
\begin{description}
    \item[RegDst]Â Controls which part of the instruction that indicates which
        B register to read from.

    \item[Branch] Controls whether or not the instruction is a branch
        instruction.

    \item[MemRead] Controls whether or not there should be read from memory.

    \item[MemtoReg] Controls whether or not the value from memory should be
        stored in the register file.

    \item[ALUOp] Opcode indicating which operation should be performed in
        the ALU. It is send to the ALU Control for further processing.

    \item[MemWrite] Controls whether or not data should be written to memory.

    \item[ALUSrc] Controls whether the B input for the ALU should be the
        value read from the register file, or if it should be the value
        extracted from the instruction.

    \item[RegWrite] Controls whether or not data should be written to the
        register file.

%    \item[Jump] Controls whether or not the instruction is a jump instruction,
%        i.e. if the \texttt{PC} register should be changed.

%    \item[JAL] Contrals whether or not the instruction is a \texttt{jal}
%        instruction, i.e. that the \texttt{PC+4} address should be stored.

%    \item[LogicalImmediate] Controls whether or not the sign extender should
%        be a sign extender, in the case of a numeral immediate, or if it
%        should be a zero extender, in the case of a logical I-format
%        instruction.
\end{description}
Each of the control flags goes to their respective part of the processor.
We will return to this component, when we have to extend it to handle more
instructions.

\subsubsection*{Implementation \& Testing}
The book describes the logic needed to implement this unit. However, it only
describes the logic for the before mentioned instructions, and is therefore
hard to extend. Therefore, we start by making an extendable Control Unit.

As with the ALU, start by having an \texttt{enum} for both the opcode and the
ALUOp. Then the process should \texttt{switch}Â on the opcode, and set the flags
accordingly. This way, adding more instructions is just adding entries in the
\texttt{enum}s, and adding cases to the \texttt{switch}, and then it is up to
the VHDL generator to construct the logic.

As with the Register File and the ALU, we test the Control Unit, by having a
tester process, which sends input, and verifies the output values.

\subsection{ALU control}\label{sec:alu-control}
The ALU control is used for generating the ALU Operation control code, which
the ALU uses for selecting which operation to perform. It takes two inputs: the
\texttt{ALUOp} code from the control unit, and the \texttt{funct} code from the
instruction, and it computes its output based on these.

If the \texttt{ALUOp} from the control unit indicates that the instruction is
an R format instruction, it uses the \texttt{funct} code for selecting the
operation.  Otherwise it bases its output purely on the \texttt{ALUOp}Â code. As
before, we will return to this component, when we need to extend the
instruction set.

\subsubsection*{Implementation \& Testing}
As with the main Control Unit, the book describes usable logic, but it does not
correspond to our own ALUOp from the Control Unit, or the needed ALU Operation
codes for the ALU. As such, we should do the same as in the Control Unit. We
start by checking whether or not the opcode from the instruction indicates that
the instruction is an R-format. If this is the case, we need to \texttt{switch}
on the \texttt{funct} field of the instuction, otherwise \texttt{switch} on the
opcode from the ALUOp.

It is tested in the same manner as the Control Unit.

\subsection{Splitter}
This is a very simple component, but it is still used in the decoding step of
the processor. It takes the instruction, which has been fetched from memory,
and divides it into chunks for the different parts of the decoding. The
instruction is partitioned as followed (the bits are inclusive):
\begin{itemize}
    \item Opcode - bits 26-31
    \item Read Address A - bits 21-25
    \item Read Address B - bits 16-20
    \item Write Address - bits 11-15
    \item Immediate - bits 0-15
    \item Funct - bits 0-5
\end{itemize}

\subsubsection*{Implementation \& Testing}
The implementation is straightforward: We take the instruction comming from the
instruction fetch part of the processor, and extract the bits at the indices,
by using C\# bit hacking. Finally, output the extracted values on the
respective output busses.

As before, testing is performed by constructing a tester process, which sends
input, and verifies the output.

\subsection{Sign Extend}
The Sign Extend is used for extracting values from the instruction. It takes
its input, which is 16-bit, and converts it into a 32-bit value, extending the
sign if present.

\subsubsection*{Implementation \& Testing}
The SME proces takes the 16-bit immediate, and outputs it on its 32-bit output
bus. C\# handles the sign extension for us.

It is tested in the same manner as the previous components.

\subsection{Instruction Memory}
The Instruction Memory is the part of the processor, which holds the program.
It has a chunk of memory, and for each clock, it outputs the value at the given
address. It has one input, the program counter, and one output, the read
instruction.

\subsubsection*{Implementation \& Testing}
Upon receiving all of its inputs, the SME process should read the address from
the Program Counter bus, and output the value stored in the memory at the read
address.

Usually the memory should be a \texttt{byte} array. However, since we are
working with C\#, we can just use a \texttt{int} array for simplicity, as we do
not have to worry about word alignment.

The Instruction Memory is tested in the same manner as the previous components.

%\subsection{Jump control}
%The jump control is the part of the processor, that based on the instruction
%changes the value of the PC register. There are two ways to jump: by branching
%and by jumping.
%
%\subsubsection*{Implementation}
%We start by implementing the control for the branching logic. We need to
%support 2 branch instructions in our basic processor: branch equal and branch
%not equal. Therefore we will need two signals: \texttt{Branch} and
%\texttt{BranchNot}. The \texttt{Branch}Â is used to indicate that the
%instruction should change the PC register. The \texttt{BranchNot} is used to
%choose whether or not the \texttt{Zero} flag from the ALU should be
%\texttt{1}Â or \texttt{0} for the instruction to branch. In both instructions,
%we compute the subtraction of the two input registers, and if the result is
%\texttt{1} they are equal, otherwise they are not equal. The \texttt{Zero}
%signal is then send to an \texttt{AND} gate along with the \texttt{Branch}
%signal.
%
%Then we need to implement the jump unit. This is a little bit easier, as we do
%not depend on anything from the ALU. The problem is that we need to change the
%decoder to accept a new format: the J-format. The J-format consists of an
%opcode, and a 26-bit address. The address is left shifted by 2, to ensure word
%alignment, and the upper 4 bits of the PC is added to the final address. We
%also need another control signal: \texttt{Jump}. We use this to multiplex
%between the newly computed address and the output from the previous mux (branch
%or pc+4).
%
%\subsubsection*{Testing}
%We test the jump unit by adding jump instructions in the program within the
%Instruction Memory.

\subsection{Memory unit}
The memory unit is the main memory. The CPU can either read or write to the
memory unit. The addresses for the memory are word sized, i.e. in the 32-bit
processor, the word size is 32 bit. The Memory Unit has four inputs: Address,
Data, \texttt{MemRead} and \texttt{MemWrite}. It has a single output: Read
Data. In one clock, the Memory Unit either reads or writes.

\subsubsection*{Implementation \& Testing}
As with the Instruction Memory, we are going to need a chunk of memory.
However, this time we do want to construct it using a \texttt{byte} array, as
later programs expect this. As such, the SME process needs to pack four bytes
into an \texttt{int} value.

In each clock, the process should check if the \texttt{MemRead} flag is set, in
which case it should read the value on the Address bus, and output the value
stored in memory at the read address. Then it should check if the
\texttt{MemWrite} flag is set, in which case it should read the value at the
Address bus and the Data bus, store the read data in memory at the read
address.

The Memory Unit is tested in the same manner as the Register File.

\subsection{Write back}
The final stage of the processor is the Write Back. Here, the values are sent
to the Register File for storing.

\subsubsection*{Implementation \& Testing}
Usually in the single cycle MIPS processor, there is nothing special in the
Write Back. However, in SME we are not allowed to have unclocked cycles, and
there is a cycle from the Register File, through the ALU and the Memory Unit,
and back to the Register File.

To solve this, we introduce a Write Buffer. The write buffer takes the Write
Data, Write Register and \texttt{WriteEnabled}Â as input, and produces the same
output. On each clock, it should output its stored values, and store its input
values.

Testing is performed in the same manner as the previous components.

%\subsection{Adding additional instructions}
%To add additional instructions, we need to add additional circuitry and entries
%in the \tt{enum}s. We will go through implementing the MIPS core instruction
%set.
%
%We start with the remaining R format instructions (Except for shifting,
%multiplication and division). This is straightforward, as we only need to add
%additional entries to the \tt{enum}s, add the additional cases in the
%\tt{switch} in the ALU control and in the \tt{switch} in the ALU.
%
%For shifting, we need to extract extra information from the instruction in the
%Splitter: the \tt{shamt} field. Following this, we add an additional control
%signal, and multiplex on whether it should be the value read from the registers
%or the \tt{shamt}, which should be the B input for the ALU.
%
%Then we have the remaining arithmetic I format instructions. This is also
%straightforward, as we only need to extend the \tt{enum}s, and add additional
%entries to the \tt{switch} in the ALU control.
%
%Next we need the \tt{jal} instruction. Here we need circuitry to store the
%contents of the \tt{PC} register. To do this, we send the \tt{PC} to the
%\tt{EX} stage, and multiplex on the output from the ALU and the \tt{PC}, with
%the \tt{JAL} control signal.
%
%Next we need the \tt{jr} instruction. We add an additional signal, and
%multiplex on the value read from register, and the normal \tt{PC+4}.
%
%Then we have the \tt{mult}, \tt{multu}, \tt{div} and \tt{divu} instructions.
%These are all R format, so we follow the same procedure. However, instead of
%sending the result on the ALU result bus, we store it in two additional
%registers, which we keep in the ALU: \tt{HI} and \tt{LO}. Following this, we
%can also easily add the instructions \tt{mfhi}, \tt{mflo}, \tt{mthi} and
%\tt{mtlo}, which moves data to and from the two new registers.
%
%Finally, we have the \tt{bne} instruction. We add an additional signal, and
%multiplex the \tt{NOT}ed \tt{zero} signal from the ALU as the signal for the
%branching \tt{AND} gate.
%
%\subsection{Test programs}
%Snak om at bruge MARS!
%
%Now that we have our single cycle MIPS processor, we are ready to throw actual
%instructions at it. We start by collecting all of the smaller test instructions
%into a full test program. SE APPENDIX! (og lav det for den sags skyld)
%
%Then we have a Quicksort written in MIPS assembly.
