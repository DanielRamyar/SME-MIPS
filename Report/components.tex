The components are mentioned in order of implementation.

\subsection{Register file}
The register file is the component that holds values for the processor. It is
the first step in a memory hierarchy, and thus the fastest memory available.
There are 32 registers in a 32-bit MIPS processor. The registers are devided
into groups based on their usage. This does not matter from a hardware
perspective, except for register 0, which is immutable and always 0.

A register file has 5 inputs: Read address A, Read address B, Write enabled,
Write address and Write data. It also has two outputs: Output A and Output B.
We need to be careful of the order in which we read and write from the register
file. We need to make sure that when an instruction reads from the register
file, it always gets the latest data, i.e. if an instruction reads from the
same register as a previous instruction writes to, it should get the written
value. This is easy to fix in the single cycle processor, as we just need to
write before reading.

\begin{figure}
    \centering
    \begin{tikzpicture}[node distance=2cm]
        \node[empty] (inputa) {Input A};
        \node[empty, below of=inputa] (inputb) {InputB};

        \node[empty, right of=inputa] (spacing) at ($(inputa)!0.5!(inputb)$) {};
        \node[block, right of=spacing] (register) {Register};
        \node[empty, below of=register] (writedata) {Write data};
        \node[empty, left of=writedata] (write) {Write register};
        \node[empty, right of=writedata] (writeenabled) {Write enabled};

        \node[empty, right of=inputa] (space) {};
        \node[empty, right of=space] (spacee) {};
        \node[empty, right of=spacee] (spaceee) {};
        \node[empty, right of=spaceee] (outputa) {Output A};
        \node[empty, below of=outputa] (outputb) {Output B};
        \node[empty, left of=outputb] (bspace) {};

        \path[draw, -] (inputa) -| (spacing.north);
        \path[draw, ->] (spacing.north) |- (register.155);
        \path[draw, -] (inputb) -| (spacing.south);
        \path[draw, ->] (spacing.south) |- (register.205);

        \path[draw, -] (write) |- (writedata.135);
        \path[draw, ->] (writedata.135) -- (register.225);
        \path[draw, ->] (writedata) -- (register);
        \path[draw, -] (writeenabled) |- (writedata.45);
        \path[draw, ->] (writedata.45) -- (register.315);

        \path[draw, -] (register.335) -| (bspace.north);
        \path[draw, ->] (bspace.north) |- (outputb);
        \path[draw, -] (register.25) -| (spaceee.south);
        \path[draw, ->] (spaceee.south) |- (outputa);
    \end{tikzpicture}
    \caption{The register file}
    \label{fig:register}
\end{figure}

\bf{Testing} - I start by testing if some of the initial values of the register
file is correctly set to 0. Then I test if I can write to a register, and
whether or not I can read the same value from the same address in the register.
Then, I try to write to all of the registers, except for 0, and check whether
or not the output that I get, corresponds with the output that I wrote.

\subsection{ALU}
The ALU (Arithmetic Logic Unit) is the part of the processor, which makes the
actual computation. It takes three inputs: InputA, InputB and an ALU opcode
indicating which computation to perform. It has two outputs: The result of the
computation, and a zero flag indicating whether or not the result of the
computation was 0.

\begin{figure}
    \centering
    \begin{tikzpicture} [node distance=1.5cm]
        \node[empty] (ina) {Input A};
        \node[empty, below of=ina] (inb) {Input B};
        \node[empty, right of=inputa] (spacing) at ($(ina)!0.5!(inb)$) {};
        \node[block, right of=spacing] (alu) {ALU};
        \node[empty, right of=ina] (align0) {};
        \node[empty, right of=align0] (align1) {};
        \node[empty, right of=align1] (align2) {};
        \node[empty, right of=align2] (result) {Result};
        \node[empty, below of=result] (zero) {Zero};
        \node[empty, left of=zero] (align3) {};
        \node[empty, below of=alu] (aluop) {ALUOp};

        \path[draw, -] (ina.east) -| (spacing.155);
        \path[draw, ->] (spacing.155) -- (alu.155);
        \path[draw, -] (inb.east) -| (spacing.205);
        \path[draw, ->] (spacing.205) -- (alu.205);
        \path[draw, ->] (aluop) -- (alu);
        \path[draw, -] (alu.25) -| (align2.east);
        \path[draw, ->] (align2.east) -- (result);
        \path[draw, -] (alu.335) -| (align3.east);
        \path[draw, ->] (align3.east) -- (zero);
    \end{tikzpicture}
    \caption{The ALU}
    \label{fig:alu}
\end{figure}

I follow the approach from the book % TODO ref!
and have implemented the basic processor operations: \texttt{add}, \texttt{sub},
\texttt{and}, \texttt{or}, \texttt{slt}, \texttt{sw}, \texttt{lw} and
\texttt{beq}. The encoding of the ALU opcode is described in Section
\ref{sec:alu-control}

I have tested each of the eight operations, and by looking at the results from
the ALU, the results look sane.

\subsection{Control Unit}
The control unit is part of the decoding step. It takes the opcode of the
instruction, and based on the opcode, it sets control flags used throughout the
processor. It sets the following seven control flags:
\begin{description}
    \item[RegDst] Controls which part of the instruction that indicates which
        B register to read from.

    \item[Branch] Controls whether or not the instruction is a branch
        instruction.

    \item[MemRead] Controls whether or not there should be read from memory.

    \item[MemtoReg] Controls whether or not the value from memory should be
        stored in the register file.

    \item[ALUOp] Two bits indicating which operation should be performed in
        the ALU. It is send to the ALU control for further processing.

    \item[MemWrite] Controls whether or not data should be written to memory.

    \item[ALUSrc] Controls whether the B input for the ALU should be the
        value read from the register file, or if it should be the value
        extracted from the instruction.

    \item[RegWrite] Controls whether or not data should be written to the
        register file.
\end{description}
Each of the control flags goes to their respective part of the processor.

\subsection{ALU control}\label{sec:alu-control}
The ALU control is used for generating the control code, which the ALU uses for
selecting which operation to perform. It takes two inputs: the \texttt{ALUOp}
code from the control unit, and the \texttt{funct} code from the instruction,
and it computes its output based on these. If the \texttt{ALUOp} from the
control unit indicates that the instruction is an R format instruction, it uses
the \texttt{funct} code for selecting the operation. Otherwise it bases its
output purely on the \texttt{ALUOp} code.

\subsection{Instruction memory}
\subsection{Jump control}
\subsection{Memory unit}
\subsection{Write back}
% TODO write buffer i ID steppet!
