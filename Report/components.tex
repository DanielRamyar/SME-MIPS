In this section, we will be looking at the major components of the MIPS
processor. For each component, we will go through the theory of the component,
then we will look at translating theory into an SME implementation, and the
verification of the implementations. The order in which the components are
mentioned, is the order of implementation.

By the end of this section, we should have all of the required resources for
building our single cycle MIPS processor using SME.

\subsection{Register file}
The register file is the component that holds values for the processor. It is
the first step in a memory hierarchy, and is thus the fastest memory available.
There are 32 registers in a 32-bit MIPS processor. The registers are devided
into groups based on their usage. This does not matter from a hardware
perspective, except for register 0, which is immutable and always 0.

A register file has 5 inputs: Read address A, Read address B, Write enabled,
Write address and Write data. It also has two outputs: Output A and Output B.
We need to be careful of the order in which we read and write from the register
file. We need to make sure that when an instruction reads from the register
file, it always gets the latest data, i.e. if an instruction reads from the
same register as a previous instruction writes to, it should get the newly
written value. This is easy to fix in the single cycle processor, as we just
need to write before reading. The register file and its inputs and outputs can
be seen in Figure \ref{fig:register}.

\begin{figure}
    \centering
    \begin{tikzpicture}[node distance=2cm]
        \node[empty] (inputa) {Input A};
        \node[empty, below of=inputa] (inputb) {InputB};

        \node[empty, right of=inputa] (spacing) at ($(inputa)!0.5!(inputb)$) {};
        \node[block, right of=spacing] (register) {Register};
        \node[empty, below of=register] (writedata) {Write data};
        \node[empty, left of=writedata] (write) {Write register};
        \node[empty, right of=writedata] (writeenabled) {Write enabled};

        \node[empty, right of=inputa] (space) {};
        \node[empty, right of=space] (spacee) {};
        \node[empty, right of=spacee] (spaceee) {};
        \node[empty, right of=spaceee] (outputa) {Output A};
        \node[empty, below of=outputa] (outputb) {Output B};
        \node[empty, left of=outputb] (bspace) {};

        \path[draw, -] (inputa) -| (spacing.north);
        \path[draw, ->] (spacing.north) |- (register.155);
        \path[draw, -] (inputb) -| (spacing.south);
        \path[draw, ->] (spacing.south) |- (register.205);

        \path[draw, -] (write) |- (writedata.135);
        \path[draw, ->] (writedata.135) -- (register.225);
        \path[draw, ->] (writedata) -- (register);
        \path[draw, -] (writeenabled) |- (writedata.45);
        \path[draw, ->] (writedata.45) -- (register.315);

        \path[draw, -] (register.335) -| (bspace.north);
        \path[draw, ->] (bspace.north) |- (outputb);
        \path[draw, -] (register.25) -| (spaceee.south);
        \path[draw, ->] (spaceee.south) |- (outputa);
    \end{tikzpicture}
    \caption{The register file}
    \label{fig:register}
\end{figure}

\subsubsection*{Implementation}
The implementation of the register file in SME is done by the use of an
\texttt{int} array. We construct a process, that when all of its inputs are
ready, it takes the write input, and stores it in the array with the given
index, which is greater than 0, if the \texttt{RegWrite} flag has been set. We
will explain the flag in more detail in Section \ref{sec:control-unit}. In case
we do get a 0, we just ignore the request, as this is usually the pattern of a
\texttt{nop} instruction.

After the process have written to the register, it then processes the read
addresses, and outputs the values stored in the array at the given indices.

\subsubsection*{Testing}
I start by testing if some of the initial values of the register file is
correctly set to 0. Then I test if I can write to a register, and whether or
not I can read the same value from the same address in the register.  Then, I
try to write to all of the registers, except for 0, and check whether or not
the output that I get, corresponds with the output that I tried to write.

\subsection{ALU}
The ALU (Arithmetic Logic Unit) is the part of the processor, which makes the
actual computation. It takes three inputs: InputA, InputB and an ALU opcode
indicating which computation to perform. It has two outputs: The result of the
computation, and a zero flag indicating whether or not the result of the
computation was 0. The overview of the component and its inputs and outputs can
be seen in Figure \ref{fig:alu}.

\begin{figure}
    \centering
    \begin{tikzpicture} [node distance=1.5cm]
        \node[empty] (ina) {Input A};
        \node[empty, below of=ina] (inb) {Input B};
        \node[empty, right of=inputa] (spacing) at ($(ina)!0.5!(inb)$) {};
        \node[block, right of=spacing] (alu) {ALU};
        \node[empty, right of=ina] (align0) {};
        \node[empty, right of=align0] (align1) {};
        \node[empty, right of=align1] (align2) {};
        \node[empty, right of=align2] (result) {Result};
        \node[empty, below of=result] (zero) {Zero};
        \node[empty, left of=zero] (align3) {};
        \node[empty, below of=alu] (aluop) {ALUOp};

        \path[draw, -] (ina.east) -| (spacing.155);
        \path[draw, ->] (spacing.155) -- (alu.155);
        \path[draw, -] (inb.east) -| (spacing.205);
        \path[draw, ->] (spacing.205) -- (alu.205);
        \path[draw, ->] (aluop) -- (alu);
        \path[draw, -] (alu.25) -| (align2.east);
        \path[draw, ->] (align2.east) -- (result);
        \path[draw, -] (alu.335) -| (align3.east);
        \path[draw, ->] (align3.east) -- (zero);
    \end{tikzpicture}
    \caption{The ALU}
    \label{fig:alu}
\end{figure}

\subsubsection*{Implementation}
I follow the approach from the book % TODO ref!
and have implemented the basic processor operations: \texttt{add}, \texttt{sub},
\texttt{and}, \texttt{or}, \texttt{slt}, \texttt{sw}, \texttt{lw} and
\texttt{beq}. The encoding of the ALU opcode is described in Section
\ref{sec:alu-control}. The book explains which ALUOp inputs should trigger
which computation. Doing this in SME is straightforward, we read from the ALUOp
bus, and then we have a \texttt{switch}, and for the instructions that we do
accept, we take the input from the two input busses, do the computation, and
output the result on the resulting bus. Finally, output on the zero bus,
whether or not the computation was 0.

\subsubsection*{Testing}
For each of the operations that the ALU can perform, I have tested if the
output from the ALU matches the expected value.

\subsection{Control Unit}
\label{sec:control-unit}
The control unit is part of the decoding step. It takes the opcode of the
instruction, and based on the opcode, it sets control flags used throughout the
processor. It sets the following seven control flags:
\begin{description}
    \item[RegDst] Controls which part of the instruction that indicates which
        B register to read from.

    \item[Branch] Controls whether or not the instruction is a branch
        instruction.

    \item[MemRead] Controls whether or not there should be read from memory.

    \item[MemtoReg] Controls whether or not the value from memory should be
        stored in the register file.

    \item[ALUOp] Two bits indicating which operation should be performed in
        the ALU. It is send to the ALU control for further processing.

    \item[MemWrite] Controls whether or not data should be written to memory.

    \item[ALUSrc] Controls whether the B input for the ALU should be the
        value read from the register file, or if it should be the value
        extracted from the instruction.

    \item[RegWrite] Controls whether or not data should be written to the
        register file.
\end{description}
Each of the control flags goes to their respective part of the processor.
We will return to this component, when we have to extend it to handle more
instructions.

\subsubsection*{Implementation}
The book describes the logic behind generating the logic for this unit, but I
have just implemented the combinatorial logic from the book, in the same manner
as in Section \ref{sec:logic-circuits}.

\subsubsection*{Testing}
meh - det er gjort dog...

\subsection{ALU control}\label{sec:alu-control}
The ALU control is used for generating the control code, which the ALU uses for
selecting which operation to perform. It takes two inputs: the \texttt{ALUOp}
code from the control unit, and the \texttt{funct} code from the instruction,
and it computes its output based on these. If the \texttt{ALUOp} from the
control unit indicates that the instruction is an R format instruction, it uses
the \texttt{funct} code for selecting the operation. Otherwise it bases its
output purely on the \texttt{ALUOp} code. As before, we will return to this
component, when we need to extend the instruction set.

\subsubsection*{Implementation}
As with the main control unit, I have just implemented the combinatorial logic
from the book.

\subsubsection*{Testing}
Pretty much det samme som før

\subsection{Splitter}
This is a very simple component, but it is still used in the decoding step of
the processor. It takes the instruction, which has been fetched from memory,
and divides it into chunks for the different parts of the decoding, e.g. the
control unit only need the 6 most significant bits of the instruction, as this
makes up the opcode of the instruction.

\subsubsection*{Implementation}
The implementation is straightforward: We take the instruction comming from the
instruction fetch part of the processor, and extract the bits at the indices
specified in the book (eller lav egen tegning!)

\subsubsection*{Testing}
Meh, der er lavet en smule, da jeg tester både splitter, register og alu
samtidig.

% Merge alle de små komponenter sammen, så der ikke er så mange små afsnit?
\subsection{Sign extend}
This component is used for converting values within the immediate field of an
instruction, which is 16-bit, to a 32-bit number, maintaining the sign value.

\subsubsection*{Implementation}
To implement this, I just take the value from an input bus, which contains a
\texttt{short} value, and send it along the output bus, which contains an
\texttt{int} value.

\subsubsection*{Testing}
Jeg har jo ikke testet dem individuelt...

\subsection{Instruction memory}
The instruction memory consists of three parts: the \texttt{PC} register, which
is the address of the current program line. The program memory, which is just
like the memory unit, a chunk of memory. And an \texttt{PC} incrementer, which
adds word length to the \texttt{PC} after every instruction.

\subsubsection*{Implementation}
The PC is just a clocked process, that forwards its input. The program memory,
is like the register file, but with less connections. It only has a single
input and a single output bus. It takes the address given on the input bus,
extracts the instruction from the instruction memory, and sends the instruction
on its output bus.

The incrementer just adds 1 to its input. In the book, it states that it should
be 4 added to the program counter. However, since we are working in C\#, we can
just use an \texttt{int} array, and instead of adding 4, we just add 1, as this
will increment where in memory we are pointing.

\subsubsection*{Testing}
It has been tested! IF has a program that it pushes through the processor.

\subsection{Jump control}
\subsection{Memory unit}
\subsection{Write back}
% TODO write buffer i ID steppet!
