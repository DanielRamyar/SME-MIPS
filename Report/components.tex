In this section, we will be looking at the major components of the MIPS
processor. For each component, we will go through the theory of the component,
then we will look at translating theory into an SME implementation, and the
verification of the implementations. The order in which the components are
mentioned, is the order of implementation.

By the end of this section, we should have all of the required resources for
building our single cycle MIPS processor using SME.

\subsection{Register file}
The register file is the component that holds values for the processor. It is
the first step in a memory hierarchy, and is thus the fastest memory available.
There are 32 registers in a 32-bit MIPS processor. The registers are devided
into groups based on their usage. This does not matter from a hardware
perspective, except for register 0, which is immutable and always 0.

A register file has 5 inputs: Read address A, Read address B, Write enabled,
Write address and Write data. It also has two outputs: Output A and Output B.
We need to be careful of the order in which we read and write from the register
file. We need to make sure that when an instruction reads from the register
file, it always gets the latest data, i.e. if an instruction reads from the
same register as a previous instruction writes to, it should get the newly
written value. This is easy to fix in the single cycle processor, as we just
need to write before reading. The register file and its inputs and outputs can
be seen in Figure \ref{fig:register}.

\begin{figure}
    \centering
    \begin{tikzpicture}[node distance=2cm]
        \node[empty] (inputa) {Input A};
        \node[empty, below of=inputa] (inputb) {InputB};

        \node[empty, right of=inputa] (spacing) at ($(inputa)!0.5!(inputb)$) {};
        \node[block, right of=spacing] (register) {Register};
        \node[empty, below of=register] (writedata) {Write data};
        \node[empty, left of=writedata] (write) {Write register};
        \node[empty, right of=writedata] (writeenabled) {Write enabled};

        \node[empty, right of=inputa] (space) {};
        \node[empty, right of=space] (spacee) {};
        \node[empty, right of=spacee] (spaceee) {};
        \node[empty, right of=spaceee] (outputa) {Output A};
        \node[empty, below of=outputa] (outputb) {Output B};
        \node[empty, left of=outputb] (bspace) {};

        \path[draw, -] (inputa) -| (spacing.north);
        \path[draw, ->] (spacing.north) |- (register.155);
        \path[draw, -] (inputb) -| (spacing.south);
        \path[draw, ->] (spacing.south) |- (register.205);

        \path[draw, -] (write) |- (writedata.135);
        \path[draw, ->] (writedata.135) -- (register.225);
        \path[draw, ->] (writedata) -- (register);
        \path[draw, -] (writeenabled) |- (writedata.45);
        \path[draw, ->] (writedata.45) -- (register.315);

        \path[draw, -] (register.335) -| (bspace.north);
        \path[draw, ->] (bspace.north) |- (outputb);
        \path[draw, -] (register.25) -| (spaceee.south);
        \path[draw, ->] (spaceee.south) |- (outputa);
    \end{tikzpicture}
    \caption{The register file}
    \label{fig:register}
\end{figure}

\subsubsection*{Implementation}
The implementation of the register file in SME is done by the use of an
\texttt{int} array. We construct a process, that when all of its inputs are
ready, it takes the write input, and stores it in the array with the given
index, which is greater than 0, if the \texttt{RegWrite} flag has been set. We
will explain the flag in more detail in Section \ref{sec:control-unit}. In case
we do get a 0, we just ignore the request, as this is usually the pattern of a
\texttt{nop} instruction.

After the process have written to the register, it then processes the read
addresses, and outputs the values stored in the array at the given indices.

\subsubsection*{Testing}
I start by testing if some of the initial values of the register file is
correctly set to 0. Then I test if I can write to a register, and whether or
not I can read the same value from the same address in the register.  Then, I
try to write to all of the registers, except for 0, and check whether or not
the output that I get, corresponds with the output that I tried to write.

\subsection{ALU}
The ALU (Arithmetic Logic Unit) is the part of the processor, which makes the
actual computation. It takes three inputs: InputA, InputB and an ALU opcode
indicating which computation to perform. It has two outputs: The result of the
computation, and a zero flag indicating whether or not the result of the
computation was 0. The overview of the component and its inputs and outputs can
be seen in Figure \ref{fig:alu}.

\begin{figure}
    \centering
    \begin{tikzpicture} [node distance=1.5cm]
        \node[empty] (ina) {Input A};
        \node[empty, below of=ina] (inb) {Input B};
        \node[empty, right of=inputa] (spacing) at ($(ina)!0.5!(inb)$) {};
        \node[block, right of=spacing] (alu) {ALU};
        \node[empty, right of=ina] (align0) {};
        \node[empty, right of=align0] (align1) {};
        \node[empty, right of=align1] (align2) {};
        \node[empty, right of=align2] (result) {Result};
        \node[empty, below of=result] (zero) {Zero};
        \node[empty, left of=zero] (align3) {};
        \node[empty, below of=alu] (aluop) {ALUOp};

        \path[draw, -] (ina.east) -| (spacing.155);
        \path[draw, ->] (spacing.155) -- (alu.155);
        \path[draw, -] (inb.east) -| (spacing.205);
        \path[draw, ->] (spacing.205) -- (alu.205);
        \path[draw, ->] (aluop) -- (alu);
        \path[draw, -] (alu.25) -| (align2.east);
        \path[draw, ->] (align2.east) -- (result);
        \path[draw, -] (alu.335) -| (align3.east);
        \path[draw, ->] (align3.east) -- (zero);
    \end{tikzpicture}
    \caption{The ALU}
    \label{fig:alu}
\end{figure}

\subsubsection*{Implementation}
I follow the approach from the book % TODO ref!
and have implemented the basic processor operations: \texttt{add}, \texttt{sub},
\texttt{and}, \texttt{or}, \texttt{slt}, \texttt{sw}, \texttt{lw} and
\texttt{beq}. The encoding of the ALU opcode is described in Section
\ref{sec:alu-control}. The book explains which ALUOp inputs should trigger
which computation. Doing this in SME is straightforward, we read from the ALUOp
bus, and then we have a \texttt{switch}, and for the instructions that we do
accept, we take the input from the two input busses, do the computation, and
output the result on the resulting bus. Finally, output on the zero bus,
whether or not the computation was 0.

\subsubsection*{Testing}
For each of the operations that the ALU can perform, I have tested if the
output from the ALU matches the expected value.

\subsection{Control Unit}
\label{sec:control-unit}
The control unit is part of the decoding step. It takes the opcode of the
instruction, and based on the opcode, it sets control flags used throughout the
processor. It sets the following control flags:
\begin{description}
    \item[RegDst] Controls which part of the instruction that indicates which
        B register to read from.

    \item[Branch] Controls whether or not the instruction is a branch
        instruction.

    \item[MemRead] Controls whether or not there should be read from memory.

    \item[MemtoReg] Controls whether or not the value from memory should be
        stored in the register file.

    \item[ALUOp] Two bits indicating which operation should be performed in
        the ALU. It is send to the ALU control for further processing.

    \item[MemWrite] Controls whether or not data should be written to memory.

    \item[ALUSrc] Controls whether the B input for the ALU should be the
        value read from the register file, or if it should be the value
        extracted from the instruction.

    \item[RegWrite] Controls whether or not data should be written to the
        register file.

    \item[Jump] Controls whether or not the instruction is a jump instruction,
        i.e. if the \texttt{PC} register should be changed.

    \item[JAL] Contrals whether or not the instruction is a \texttt{jal}
        instruction, i.e. that the \texttt{PC+4} address should be stored.

    \item[LogicalImmediate] Controls whether or not the sign extender should
        be a sign extender, in the case of a numeral immediate, or if it
        should be a zero extender, in the case of a logical I-format
        instruction.
\end{description}
Each of the control flags goes to their respective part of the processor.
%We will return to this component, when we have to extend it to handle more
%instructions.

\subsubsection*{Implementation}
%The book describes the logic behind generating the logic for this unit, but I
%have just implemented the combinatorial logic from the book, in the same manner
%as in Section \ref{sec:logic-circuits}.
To implement this, I have simply made a \texttt{switch} statement on the
opcode. Then, for each type of opcode, I set the appropiate flags and the
\texttt{ALUOpcode}.

\subsubsection*{Testing}
meh - det er gjort dog...

\subsection{ALU control}\label{sec:alu-control}
%The ALU control is used for generating the control code, which the ALU uses for
%selecting which operation to perform. It takes two inputs: the \texttt{ALUOp}
%code from the control unit, and the \texttt{funct} code from the instruction,
%and it computes its output based on these. If the \texttt{ALUOp} from the
%control unit indicates that the instruction is an R format instruction, it %uses
%the \texttt{funct} code for selecting the operation. Otherwise it bases its
%output purely on the \texttt{ALUOp} code. As before, we will return to this
%component, when we need to extend the instruction set.
As with the normal Control Unit, we need to produce a signal, based on some
input. We start by checking whether or not the opcode from the instruction
indicates that the instruction is an R-format. If this is the case, we need to
\texttt{switch} on the \texttt{funct} field of the instuction.
% TODO ALU har HI og LO

\subsubsection*{Implementation}
As with the main control unit, I have just implemented the combinatorial logic
from the book.

\subsubsection*{Testing}
Pretty much det samme som før

\subsection{Splitter}
This is a very simple component, but it is still used in the decoding step of
the processor. It takes the instruction, which has been fetched from memory,
and divides it into chunks for the different parts of the decoding, e.g. the
control unit only need the 6 most significant bits of the instruction, as this
makes up the opcode of the instruction.

\subsubsection*{Implementation}
The implementation is straightforward: We take the instruction comming from the
instruction fetch part of the processor, and extract the bits at the indices
specified in the book (eller lav egen tegning!)

\subsubsection*{Testing}
Meh, der er lavet en smule, da jeg tester både splitter, register og alu
samtidig.

% Merge alle de små komponenter sammen, så der ikke er så mange små afsnit?
\subsection{Sign extend}
This component is used for converting values within the immediate field of an
instruction, which is 16-bit, to a 32-bit number, maintaining the sign value.

\subsubsection*{Implementation}
To implement this, I just take the value from an input bus, which contains a
\texttt{short} value, and send it along the output bus, which contains an
\texttt{int} value.

\subsubsection*{Testing}
Jeg har jo ikke testet dem individuelt...

\subsection{Instruction memory}
The instruction memory consists of three parts: the \texttt{PC} register, which
is the address of the current program line. The program memory, which is just
like the memory unit, a chunk of memory. And an \texttt{PC} incrementer, which
adds word length to the \texttt{PC} after every instruction.

\subsubsection*{Implementation}
The PC is just a clocked process, that forwards its input. The program memory,
is like the register file, but with less connections. It only has a single
input and a single output bus. It takes the address given on the input bus,
extracts the instruction from the instruction memory, and sends the instruction
on its output bus.

The incrementer just adds 1 to its input. In the book, it states that it should
be 4 added to the program counter. However, since we are working in C\#, we can
just use an \texttt{int} array, and instead of adding 4, we just add 1, as this
will increment where in memory we are pointing.

\subsubsection*{Testing}
It has been tested! IF has a program that it pushes through the processor.

\subsection{Jump control}
The jump control is the part of the processor, that based on the instruction
changes the value of the PC register. There are two ways to jump: by branching
and by jumping.

\subsubsection*{Implementation}
We start by implementing the control for the branching logic. We need to
support 2 branch instructions in our basic processor: branch equal and branch
not equal. Therefore we will need two signals: \texttt{Branch} and
\texttt{BranchNot}. The \texttt{Branch} is used to indicate that the
instruction should change the PC register. The \texttt{BranchNot} is used to
choose whether or not the \texttt{Zero} flag from the ALU should be
\texttt{1} or \texttt{0} for the instruction to branch. In both instructions,
we compute the subtraction of the two input registers, and if the result is
\texttt{1} they are equal, otherwise they are not equal. The \texttt{Zero}
signal is then send to an \texttt{AND} gate along with the \texttt{Branch}
signal. bla bla decoder......

Then we need to implement the jump unit. This is a little bit easier, as we do
not depend on anything from the ALU. The problem is that we need to change the
decoder to accept a new format: the J-format. The J-format consists of an
opcode, and a 26-bit address. The address is left shifted by 2, to ensure word
alignment, and the upper 4 bits of the PC is added to the final address. We
also need another control signal: \texttt{Jump}. We use this to multiplex
between the newly computed address and the output from the previous mux (branch
or pc+4).

\subsubsection*{Testing}
\texttt{nop}

\subsection{Memory unit}
The memory unit is the main memory. The CPU can either read or write to the
memory unit. The addresses for the memory are word sized, i.e. in our case 32
bit.

\subsubsection*{Implementation}
We are going to need two signals: \texttt{MemRead} and \texttt{MemWrite}.
Furthermore, we need an address input, an data input and an data output. On
each clock, we first check if we should read, in which case we output the word
at the given adress, if we should write, in which case we store the word from
the data bus at the given address.

\subsubsection*{Testing}
aoeuaoeuaoeuaoeuoaeuaoeue

\subsection{Write back}
The final stage is the writeback, where we take the computed result, and store
it in the appropriate registers.

\subsubsection*{Implementation}
(Måske som førnævnt??) Since there is a cycle from the register file, through
the alu and memory, back to the register file, we need to have a clocked
buffer. As such, after each instruction, the result is stored in this buffer,
and on a clock tick, the value in hold is put on its output bus to the
registers.

\subsection*{Testing}
meh
