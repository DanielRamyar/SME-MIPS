% {{{ Preamble ----------------------------------------------------------------
\documentclass{beamer}

% encodings, fonts etc.
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

% Hold kÃ¦ft utf
\makeatletter
\def\UTFviii@defined#1{%
  \ifx#1\relax
      ?%
  \else\expandafter
    #1%
  \fi
}

\makeatother

% math packages
\usepackage{amsmath, amssymb, amsthm}
\usepackage{mathtools}

% beamer configuration
\usetheme{Copenhagen}
%\useoutertheme{infolines}
%\usetheme{metropolis}
\beamertemplatenavigationsymbolsempty
%\setbeamertemplate{theorems}[numbered]
\setbeamersize{description width=2.0em}

%\usepackage{pgfpages}
%\setbeameroption{show notes}
%\setbeameroption{show notes on second screen=right}

% algorithms
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

% misc. packages
\usepackage{float}
\usepackage{varwidth}
\usepackage{listings}
\lstset{
  %breaklines=true,
  keepspaces=true,
  %frame=ltrb,
  %framesep=1pt,
  %commentstyle=\color{grey},
  basicstyle=\ttfamily\tiny,
  %numbers=left,
  title=\lstname,
  %columns=fullflexible,
  inputencoding=utf8,
  extendedchars=true,
}

% graphics and tikz
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{positioning,arrows,calc}
\tikzset{
    on grid,
    node distance=3cm,
    auto,
    block/.style = {
        draw,
        shape=rectangle,
        minimum height=3em,
        minimum width=3em,
        line width=1pt
    },
    control/.style = {
        draw,
        shape=circle,
        minimum height=7em,
        minimum width=3em,
        line width=1pt
    },
    mux/.style = {
        draw,
        shape=rectangle,
        minimum height=1.5em,
        minimum width=1em,
        line width=1pt
    },
    empty/.style = {
        shape=rectangle,
        minimum height=3em,
        minimum width=3em
    },
    >=latex',
}


% mathematics
\newtheorem{proposition}{Proposition}

\renewcommand{\tt}{\texttt}

% title page
\title{Pipelined MIPS processor}
\author[Carl-Johannes Johnsen]{
  \mbox{Carl-Johannes Johnsen}}
\institute{Department of Computer Science\\
           University of Copenhagen}
%\date{December 22, 2016}
% }}} -------------------------------------------------------------------------

\begin{document}

% {{{ Title page --------------------------------------------------------------
\frame{\titlepage}
% }}} -------------------------------------------------------------------------

% {{{ Table of contents -------------------------------------------------------
%\begin{frame}
%  \frametitle{Outline}
%  \tableofcontents
%\end{frame}
% }}} -------------------------------------------------------------------------
\section{Introduction}
\subsection{Overview}
\begin{frame}
    In this lecture, we will be looking at pipelining our single cycle MIPS
    processor.

    \vspace{\baselineskip}
    We will go through the motivation and background for pipelining, and the
    steps for implementing it in SME.

    \vspace{\baselineskip}
    Finally, we will look at handling the problems introduced by pipelining, by
    adding two new units: the Forwarding Unit, and the Hazard Detection Unit.
\end{frame}

\subsection{Motivation \& Background}
\begin{frame}
    The single cycle MIPS processor is not very efficient, as the clock rate is
    determined by the longest possible path in the processor.

    \vspace{\baselineskip}
    In order to increase the clock rate, we must decrease the longest path in
    the processor, by introducing pipes.
\end{frame}
\begin{frame}
    Pipes are registers in the processor, which temporarely store all the
    values computed so far.

    \vspace{\baselineskip}
    This ensures that the data does not have to travel as far, until it has
    reached a safe state.
\end{frame}
\begin{frame}
    Determining where to place the pipes, is done by dividing the processor
    into stages.

    \vspace{\baselineskip}
    We will follow the classic MIPS example, and divide the processor into 5
    stages:
    \begin{itemize}
        \item Instruction Fetch (IF)
        \item Instruction Decode (ID)
        \item Execute (EX)
        \item Memory (MEM)
        \item Write Back (WB)
    \end{itemize}
    We are going to insert a pipe between each state, i.e. 4 pipes.
\end{frame}

\section{Introducing the pipes}
\subsection{Implementation}
\begin{frame}
    We have two ways of implementing pipes in SME:
    \begin{itemize}
        \item Clocked Busses - for busses which only traverses 2 stages
        \item Clocked Processes - for dividing busses traversing more than 2
            stages
    \end{itemize}
    Just adding the \texttt{ClockedBus} attribute to the busses seems simpler.
    However, it can become more explicit, by adding additional busses, and to
    have a process, which explicitly touches all of the busses, which should go
    into the pipe.
\end{frame}
\begin{frame}
    Introducing the pipes is fairly straightforward. For each pipe, we add a
    copy of the bus, which the 'next' stage needs. Then, for each pipe, we add
    an SME process, which takes all the busses from the 'previous' stage, and
    outputs their data on the matching newly added pipe bus. Finally, the
    references in the 'next' stage should be updated to look at the piped
    busses.
\end{frame}
\begin{frame}
    This process can be repeated for all of the required pipes. There is only
    one problem: the Jump Unit. The processor do not know when to jump, until
    the MEM stage, as the adresses needs to be computed in the EX stage.

    \vspace{\baselineskip}
    To solve this, the Jump Unit should be divided out to the different stages.
    The IF stage should handle incrementing the Program Counter, and choosing
    between the addresses from the MEM stage, and the incremented Program
    Counter.

    \vspace{\baselineskip}
    The EX stage should as mentioned, compute the addresses, and finally, the
    MEM stage should hold the logic for choosing between the branch address and
    the jump address.
\end{frame}
\begin{frame}
    Finally, in the single cycle MIPS processor, we added a Write Buffer in
    order to eliminate the cycle from the Register File to the Register File.

    \vspace{\baselineskip}
    However, by introducing pipes, we have also introduced buffers, and as
    such, we can remove the Write Buffer.
\end{frame}

\subsection{Testing}
\begin{frame}
    To test the pipelind processor, we could use any of the programs we have
    previously written. However, since we have pipelined the processor, we
    need to insert bubbles in our program, to ensure the data is ready for all
    of the instructions.

    \vspace{\baselineskip}
    An bubble is a No Operation (\texttt{nop}) instruction, which performs no
    operation, and touches neither the Register File nor the Memory.
\end{frame}
\begin{frame}
    We are going to implement a simple program, which is easy to verify: a
    small loop, which computes $n$ fibonacci numbers, and places them in
    memory.

    \vspace{\baselineskip}
    As we have done previously, we are going to give pseudo low level C code.
\end{frame}
\begin{frame}[fragile]
\begin{lstlisting}
void init(int *arr) {
    *(arr)   = 1;
    *(arr+1) = 1;
}

void loop(int *arr, int n) {
    int i, tmp1, tmp2, tmp3;
    for (i = 0; i < n; i++) {
        tmp1 = *(arr+i);
        tmp2 = *(arr+i+1);
        tmp3 = tmp1 + tmp2;
        *(arr+i+2) = tmp3;
    }
}
\end{lstlisting}
\end{frame}
\begin{frame}
    Note: if the program is written in actual C, the allocated array should be
    $n+2$, due to initialization values.

    \vspace{\baselineskip}
    Furthermore, when we port it to MIPS assembly, after each instruction, we
    should insert a bubble of 4 \texttt{nop}'s.

    \vspace{\baselineskip}
    When the program has run, the $n+2$ fibonacci numbers should be in memory,
    at the given address.
\end{frame}

\section{Forwarding}
\begin{frame}
    By introducing pipes, we also introduced data hazards and control hazards.
    We start by looking at handling data hazards.

    \vspace{\baselineskip}
    Data hazards are when one instruction writes to a register that a following
    instruction reads from. This was not a problem in the single cycle
    processor, as all the data had been written in the same clock cycle.
\end{frame}
\begin{frame}
    We can eliminate some of the data hazards by implementing an additional
    unit: the Forwarding Unit.

    \vspace{\baselineskip}
    This unit looks at the registers used by the instruction in the EX stage,
    and if the instruction in either the MEM or the WB stage writes to either
    of the registers, then the Forwarding will forward that data to the EX
    stage.
\end{frame}

\subsection{Implementation \& Testing}
\begin{frame}
    Implementing the Forwarding unit should be done with an SME process, which
    should be put in the EX stage.

    \vspace{\baselineskip}
    The unit should be controlling two multiplexors, which decides whether the
    EX stage should use the values read from registers, the value from the MEM
    stage or the value from the WB stage.

    \vspace{\baselineskip}
    Testing the forwarding unit is straightforward: we just remove the
    \texttt{nop}'s from the fibonacci program, except for those following a
    load, branch or jump, as these hazards are not handled yet.
\end{frame}

\section{Hazard Detection}
\subsection{Data Hazards}
\begin{frame}
    As we just mentioned, we cannot handle all of the data hazards with just
    fowarding. This is due to the forwarding destination being the EX stage,
    and that the data might not be ready at that point.

    \vspace{\baselineskip}
    E.g. if we have a load instruction, which is followed by an instruction
    that uses the loaded data in its computation. In this case, the loaded data
    will not be ready until the load instruction has reached the WB stage.

    \vspace{\baselineskip}
    To handle this, the processor needs to detect the hazard, and insert a
    bubble, and stall some of the pipes and registers.
\end{frame}

\subsection{Control Hazards}
\begin{frame}
    We also need to handle an additional type of hazard: control hazards.
    Control hazards are when either a jump or a branch instruction has been
    executed.

    \vspace{\baselineskip}
    The problem is that the branch or jump is not performed until the MEM
    stage, which means that all of the previous states of the pipeline may have
    been filled with instructions, which should not be executed.

    \vspace{\baselineskip}
    To solve this, we should detect the hazard, and in such case flush the
    pipeline. Flushing is the action of resetting the registers in the pipes,
    so they output \texttt{nop} instructions.
\end{frame}

\subsection{Implementation}
\begin{frame}
    The Hazard Detection Unit should be implemented in its own SME process.

    \vspace{\baselineskip}
    To handle the data hazards, the process should read the \texttt{memread}
    flag from the EX stage, the destination register from the EX stage, and the
    two source register address from the ID stage. If the flag has been set,
    and the destination address match either of the two source adddresses, the
    ID/EX pipe should be flushed, the IF/ID and the PC register should be
    stalled.

    \vspace{\baselineskip}
    Stalling is setting the registers not to update, so they will output the
    same data in the next clock cycle.
\end{frame}
\begin{frame}
    To solve the control hazards, the unit should look at the signal from the
    MEM stage, which indicates whether or not jumping should be performed.

    \vspace{\baselineskip}
    In such a case, the Hazard Detection Unit should send a signal to flush the
    IF/ID, ID/EX and EX/MEM pipes. Note: the PC register should perform
    normally, even though it might have been instructed to stall, as the stall
    is now invalid.
\end{frame}

\subsection{Testing}
\begin{frame}
    Testing this is straightforward, as the processor should be able to handle
    all of our previous programs, albeit with more clock cycles.
\end{frame}

% exit section
\AtBeginSection{}
\section*{}

% {{{ Bibliography ------------------------------------------------------------
%\begin{frame}{Bibliography}
%  \tiny
%  \bibliographystyle{plain}
%  \bibliography{pl}
%\end{frame}
% }}} -------------------------------------------------------------------------

\end{document}
