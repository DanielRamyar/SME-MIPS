In this section, we will be combining the core components into a single cycle
MIPS processor, i.e. a processor where exactly one instruction is executed per
clock cycle. When it is in place, we will be writing the first program, and
compiling it into the processor, and running it.

Following the single cycle MIPS processor, we will be extending
the processor so that it can handle more instructions. Along each added
instruction, we will be extending our first program, in order to verify that
the instruction works.

Finally, we will be writing two programs, and look into compiling them into a
series of hex values, that we can copy straight into the Instruction Memory.

\subsection{Wiring up the processor}
\begin{figure}
    \centering
    \scalebox{0.5}{
        \begin{tikzpicture}
            \node[block] (reg) at (0,0) {Register file};
            \node[control] (cont) at (-1,3.5) {Control unit};
            \node[block] (jump) at (5,5.5) {Jump unit};
            \node[empty] (splitspace) at (-3,0) {};
            \node[block] (split) at (-4,0) {Splitter};
            \node[block] (if) at (-7,0) {Instruction Memory};
            \node[block] (sign) at (-1,-3) {Sign extend};
            \node[block] (alu) at (4,0) {ALU};
            \node[block] (alucont) at (4,-4) {ALU control};
            \node[block] (mem) at (8.2,0) {Memory};
            \node[mux] (memread) at (10,0) {|};
            \node[mux] (imm) at (3, -0.25) {|};
            \node[mux] (regdst) at (-2,-1) {|};
            \node[block] (pc) at (-8, 2) {PC};
            \node[block] (writebuf) at (6, -2) {Write buffer};

            \path[draw, ->] (if) -- (split);
            \path[draw, -] (split) -- (splitspace.center);
            \path[draw, ->] (splitspace.center) |- (sign);
            \path[draw, ->] (splitspace.center) |- (cont);
            \path[draw, ->] (splitspace.center) |- (reg.160);
            \path[draw, ->] (splitspace.center) |- (reg.200);
            \path[draw, ->] (splitspace.center) |- (alucont.200);
            \path[draw, ->] (splitspace.center) |- (regdst.215);
            \path[draw, ->] (reg.200) -| (-2.5, -0.5) |- (regdst.145);
            \path[draw, ->] (alucont) -| (12.5, 0) |- (jump);
            \path[draw, thick, ->] (reg.340) -| (2,-0.25) |- (imm.145);
            \path[draw, thick, ->] (2,-0.25) |- (3,0.75) -- (7,0.75) |-
            (mem.164);
            \path[draw, ->] (reg.20) -- (alu.145);
            \path[draw, ->] (alu.20) -| (jump);
            %\path[draw, ->] (alu.340) -- (jal);
            %\path[draw, ->] (jal) -- (mem.196);
            %\path[draw, ->] (jal) -- (writebuf);
            \path[draw, ->] (alu.340) -- (mem.195);
            \path[draw, ->] (imm) -- (alu.202);
            \path[draw, ->] (7, -0.22) |- (8, -1) -| (9.25,-0.5) |-
            (memread.215);
            \path[draw, ->] (mem.10) -- (memread.145);
            \path[draw, ->] (sign) -| (2.5, -1) |- (imm.215);
            \path[draw, ->] (2.5,-3) -| (12, 0) |- (jump.340);
            %\path[draw, thick, ->] (regdst) -| (5, -0.6) |- (jal.210);
            \path[draw, thick, ->] (regdst) -| (writebuf);
            \path[draw, ->] (pc) -| (if);
            \path[draw, ->] (pc) -| (-4, 4) |- (jump);
            \path[draw, ->] (jump.160) -| (pc);
            \path[draw, ->] (memread) -| (11, -1) |- (writebuf.15);
            \path[draw, dashed, ->] (writebuf.170) -| (reg.300);
            \path[draw, dashed, ->] (writebuf) -| (reg);
            \path[draw, dashed, ->, color=blue] (writebuf.190) -| (reg.240);

            \path[draw, ->, color=blue] (alucont) -- (alu);
            \path[draw, ->, color=blue] (cont.35) -| (jump.245);
            \path[draw, ->, color=blue] (cont.25) -| (11.5,0) |-
            (writebuf.345);
            \path[draw, ->, color=blue] (cont.15) -| (memread);
            \path[draw, ->, color=blue] (cont.5) -| (mem.55);
            \path[draw, ->, color=blue] (cont.355) -| (mem.125);
            \path[draw, ->, color=blue] (cont.335) -| (imm);
            \path[draw, ->, color=blue] (cont.315) -| (1.5, 0.5) |-
            (alucont.160);
            \path[draw, ->, color=blue] (cont.240) -| (regdst);

            \node[block] (clock) at (-7, -5) {Clock};
            \path[draw, ->, thick, color=green] (clock) -- (if);
            \path[draw, ->, thick, color=green] (clock) -| (writebuf);
        \end{tikzpicture}
    }
    \caption{Simple single cycle MIPS processor. The units with | indicate
    multiplexors}
    \label{fig:simple-full}
\end{figure}

\begin{figure}
    \centering
    \scalebox{0.5}{
        \begin{tikzpicture}
            \node[block] (reg) at (0,0) {Register file};
            \node[control] (cont) at (-1,3.5) {Control unit};
            \node[block] (jump) at (5,5.5) {Jump unit};
            \node[empty] (splitspace) at (-3,0) {};
            \node[block] (split) at (-4,0) {Splitter};
            \node[block] (if) at (-7,0) {Instruction Memory};
            \node[block] (sign) at (-1,-3) {Sign extend};
            \node[block] (alu) at (4,0) {ALU};
            \node[block] (alucont) at (4,-4) {ALU control};
            \node[block] (mem) at (8.2,0) {Memory};
            \node[block] (jal) at (6,-0.22) {JAL};
            \node[mux] (memread) at (10,0) {|};
            \node[mux] (shmt) at (2,1.25) {|};
            \node[mux] (imm) at (3, -0.25) {|};
            \node[mux] (regdst) at (-2,-1) {|};
            \node[block] (pc) at (-8, 2) {PC};
            \node[block] (writebuf) at (6, -2) {Write buffer};

            \path[draw, ->] (if) -- (split);
            \path[draw, -] (split) -- (splitspace.center);
            \path[draw, ->] (splitspace.center) |- (sign);
            \path[draw, ->] (splitspace.center) |- (cont);
            \path[draw, ->] (splitspace.center) |- (reg.160);
            \path[draw, ->] (splitspace.center) |- (reg.200);
            \path[draw, ->] (splitspace.center) |- (jump.200);
            \path[draw, ->] (splitspace.center) |- (alucont.200);
            \path[draw, ->] (splitspace.center) |- (regdst.215);
            \path[draw, ->] (splitspace.center) |- (shmt.145);
            \path[draw, ->] (reg.200) -| (-2.5, -0.5) |- (regdst.145);
            \path[draw, ->] (alucont) -| (12.5, 0) |- (jump);
            \path[draw, thick, ->] (reg.340) -| (2,-0.25) |- (imm.145);
            \path[draw, thick, ->] (2,-0.25) |- (3,0.75) -- (7,0.75) |-
            (mem.164);
            \path[draw, thick, ->] (reg.20) -| (1.25,0.5) |- (shmt.215);
            \path[draw, thick, -] (1.25,0.5) |- (4,2);
            \path[draw, thick, ->] (4,2) -| (jump.295);
            \path[draw, ->] (shmt) -| (2.5, 0.5) |- (alu.158);
            \path[draw, ->] (alu.20) -| (jump);
            \path[draw, ->] (alu.340) -- (jal);
            \path[draw, ->] (jal) -- (mem.196);
            \path[draw, ->] (imm) -- (alu.202);
            \path[draw, ->] (7, -0.22) |- (8, -1) -| (9.25,-0.5) |-
            (memread.215);
            \path[draw, ->] (mem.10) -- (memread.145);
            \path[draw, ->] (sign) -| (2.5, -1) |- (imm.215);
            \path[draw, ->] (2.5,-3) -| (12, 0) |- (jump.340);
            \path[draw, thick, ->] (regdst) -| (5, -0.6) |- (jal.210);
            \path[draw, ->] (pc) -| (if);
            \path[draw, ->] (pc) -| (-4, 4) |- (jump);
            \path[draw, ->] (jump.160) -| (pc);
            \path[draw, ->] (jal) -- (writebuf);
            \path[draw, ->] (memread) -| (11, -1) |- (writebuf.15);
            \path[draw, dashed, ->] (writebuf.170) -| (reg.300);
            \path[draw, dashed, ->] (writebuf) -| (reg);
            \path[draw, dashed, ->, color=blue] (writebuf.190) -| (reg.240);

            \path[draw, ->, color=blue] (alucont) -- (alu);
            \path[draw, ->, color=blue] (cont.55) -| (jump.220);
            \path[draw, ->, color=blue] (cont.45) -| (jump.230);
            \path[draw, ->, color=blue] (cont.35) -| (jump.245);
            \path[draw, ->, color=blue] (cont.25) -| (11.5,0) |-
            (writebuf.345);
            \path[draw, ->, color=blue] (cont.15) -| (memread);
            \path[draw, ->, color=blue] (cont.5) -| (mem.55);
            \path[draw, ->, color=blue] (cont.355) -| (mem.125);
            \path[draw, ->, color=blue] (cont.345) -| (jal);
            \path[draw, ->, color=blue] (cont.335) -| (imm);
            \path[draw, ->, color=blue] (cont.325) -| (shmt);
            \path[draw, ->, color=blue] (cont.315) -| (1.5, 0.5) |-
            (alucont.160);
            \path[draw, ->, color=blue] (cont.250) -- (sign.128);
            \path[draw, ->, color=blue] (cont.240) -| (regdst);

            \node[block] (clock) at (-7, -5) {Clock};
            \path[draw, ->, thick, color=green] (clock) -- (if);
            \path[draw, ->, thick, color=green] (clock) -| (writebuf);
        \end{tikzpicture}
    }
    \caption{Full single cycle MIPS processor. The units with | indicate
    multiplexors. Black wires indicate data wires. Blue wires indicate control
    wires. Green wires indicate clock}
    \label{fig:full}
\end{figure}


%    \item[Jump] Controls whether or not the instruction is a jump instruction,
%        i.e. if the \texttt{PC} register should be changed.

%    \item[JAL] Contrals whether or not the instruction is a \texttt{jal}
%        instruction, i.e. that the \texttt{PC+4} address should be stored.

%    \item[LogicalImmediate] Controls whether or not the sign extender should
%        be a sign extender, in the case of a numeral immediate, or if it
%        should be a zero extender, in the case of a logical I-format
%        instruction.

%\subsection{Jump control}
%The jump control is the part of the processor, that based on the instruction
%changes the value of the PC register. There are two ways to jump: by branching
%and by jumping.
%
%\subsubsection*{Implementation}
%We start by implementing the control for the branching logic. We need to
%support 2 branch instructions in our basic processor: branch equal and branch
%not equal. Therefore we will need two signals: \texttt{Branch} and
%\texttt{BranchNot}. The \texttt{Branch} is used to indicate that the
%instruction should change the PC register. The \texttt{BranchNot} is used to
%choose whether or not the \texttt{Zero} flag from the ALU should be
%\texttt{1} or \texttt{0} for the instruction to branch. In both instructions,
%we compute the subtraction of the two input registers, and if the result is
%\texttt{1} they are equal, otherwise they are not equal. The \texttt{Zero}
%signal is then send to an \texttt{AND} gate along with the \texttt{Branch}
%signal.
%
%Then we need to implement the jump unit. This is a little bit easier, as we do
%not depend on anything from the ALU. The problem is that we need to change the
%decoder to accept a new format: the J-format. The J-format consists of an
%opcode, and a 26-bit address. The address is left shifted by 2, to ensure word
%alignment, and the upper 4 bits of the PC is added to the final address. We
%also need another control signal: \texttt{Jump}. We use this to multiplex
%between the newly computed address and the output from the previous mux (branch
%or pc+4).
%
%\subsubsection*{Testing}
%We test the jump unit by adding jump instructions in the program within the
%Instruction Memory.

%\subsection{Adding additional instructions}
%To add additional instructions, we need to add additional circuitry and entries
%in the \tt{enum}s. We will go through implementing the MIPS core instruction
%set.
%
%We start with the remaining R format instructions (Except for shifting,
%multiplication and division). This is straightforward, as we only need to add
%additional entries to the \tt{enum}s, add the additional cases in the
%\tt{switch} in the ALU control and in the \tt{switch} in the ALU.
%
%For shifting, we need to extract extra information from the instruction in the
%Splitter: the \tt{shamt} field. Following this, we add an additional control
%signal, and multiplex on whether it should be the value read from the registers
%or the \tt{shamt}, which should be the B input for the ALU.
%
%Then we have the remaining arithmetic I format instructions. This is also
%straightforward, as we only need to extend the \tt{enum}s, and add additional
%entries to the \tt{switch} in the ALU control.
%
%Next we need the \tt{jal} instruction. Here we need circuitry to store the
%contents of the \tt{PC} register. To do this, we send the \tt{PC} to the
%\tt{EX} stage, and multiplex on the output from the ALU and the \tt{PC}, with
%the \tt{JAL} control signal.
%
%Next we need the \tt{jr} instruction. We add an additional signal, and
%multiplex on the value read from register, and the normal \tt{PC+4}.
%
%Then we have the \tt{mult}, \tt{multu}, \tt{div} and \tt{divu} instructions.
%These are all R format, so we follow the same procedure. However, instead of
%sending the result on the ALU result bus, we store it in two additional
%registers, which we keep in the ALU: \tt{HI} and \tt{LO}. Following this, we
%can also easily add the instructions \tt{mfhi}, \tt{mflo}, \tt{mthi} and
%\tt{mtlo}, which moves data to and from the two new registers.
%
%Finally, we have the \tt{bne} instruction. We add an additional signal, and
%multiplex the \tt{NOT}ed \tt{zero} signal from the ALU as the signal for the
%branching \tt{AND} gate.
%
%\subsection{Test programs}
%Snak om at bruge MARS!
%
%Now that we have our single cycle MIPS processor, we are ready to throw actual
%instructions at it. We start by collecting all of the smaller test instructions
%into a full test program. SE APPENDIX! (og lav det for den sags skyld)
%
%Then we have a Quicksort written in MIPS assembly.
