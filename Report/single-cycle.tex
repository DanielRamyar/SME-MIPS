In this section, we will be combining the core components into a single cycle
MIPS processor, i.e. a processor where exactly one instruction is executed per
clock cycle. When it is in place, we will be writing the first program, and
compiling it into the processor, and running it.

Following the single cycle MIPS processor, we will be extending
the processor so that it can handle more instructions. Along each added
instruction, we will be extending our first program, in order to verify that
the added instruction works.

Finally, we will be writing two larger programs, and look into compiling them
into a series of hex values, that we can copy straight into the Instruction
Memory.

\subsection{Wiring up the processor}
\begin{figure}
    \centering
    \scalebox{0.5}{
        \begin{tikzpicture}
            \node[block] (reg) at (0,0) {Register file};
            \node[control] (cont) at (-1,3.5) {Control unit};
            \node[block] (jump) at (5,5.5) {Jump unit};
            \node[empty] (splitspace) at (-3,0) {};
            \node[block] (split) at (-4,0) {Splitter};
            \node[block] (if) at (-7,0) {Instruction Memory};
            \node[block] (sign) at (-1,-3) {Sign extend};
            \node[block] (alu) at (4,0) {ALU};
            \node[block] (alucont) at (4,-4) {ALU control};
            \node[block] (mem) at (8.2,0) {Memory};
            \node[mux] (memread) at (10,0) {|};
            \node[mux] (imm) at (3, -0.25) {|};
            \node[mux] (regdst) at (-2,-1) {|};
            \node[block] (pc) at (-8, 2) {PC};
            \node[block] (writebuf) at (6, -2) {Write buffer};

            \path[draw, ->] (if) -- (split);
            \path[draw, -] (split) -- (splitspace.center);
            \path[draw, ->] (splitspace.center) |- (sign);
            \path[draw, ->] (splitspace.center) |- (cont);
            \path[draw, ->] (splitspace.center) |- (reg.160);
            \path[draw, ->] (splitspace.center) |- (reg.200);
            %\path[draw, ->] (splitspace.center) |- (alucont.200);
            \path[draw, ->] (splitspace.center) |- (2,-5.5) -| (alucont.290);
            \path[draw, ->] (splitspace.center) |- (regdst.215);
            \path[draw, ->] (reg.200) -| (-2.5, -0.5) |- (regdst.145);
            %\path[draw, ->] (alucont) -| (12.5, 0) |- (jump);
            \path[draw, thick, ->] (reg.340) -| (2,-0.25) |- (imm.145);
            \path[draw, thick, ->] (2,-0.25) |- (3,0.75) -- (7,0.75) |-
            (mem.164);
            \path[draw, ->] (reg.20) -- (alu.145);
            \path[draw, ->, dashed, color=blue] (alu.20) -| (jump);
            %\path[draw, ->] (alu.340) -- (jal);
            %\path[draw, ->] (jal) -- (mem.196);
            %\path[draw, ->] (jal) -- (writebuf);
            \path[draw, ->] (alu.340) -- (mem.195);
            \path[draw, ->] (imm) -- (alu.202);
            \path[draw, ->] (7, -0.22) |- (8, -1) -| (9.25,-0.5) |-
            (memread.215);
            \path[draw, ->] (mem.10) -- (memread.145);
            \path[draw, ->] (sign) -| (2.5, -1) |- (imm.215);
            \path[draw, ->] (2.5,-3) -| (12, 0) |- (jump.340);
            %\path[draw, thick, ->] (regdst) -| (5, -0.6) |- (jal.210);
            \path[draw, thick, ->] (regdst) -| (writebuf);
            \path[draw, ->] (pc) -| (if);
            \path[draw, ->] (pc) -| (-4, 4) |- (jump);
            \path[draw, ->] (jump.160) -| (pc);
            \path[draw, ->] (memread) -| (11, -1) |- (writebuf.15);
            \path[draw, dashed, ->] (writebuf.170) -| (reg.300);
            \path[draw, dashed, ->] (writebuf) -| (reg);
            \path[draw, dashed, ->, color=blue] (writebuf.190) -| (reg.240);

            \path[draw, ->, color=blue] (alucont) -- (alu);
            \path[draw, ->, color=blue] (cont.35) -| (jump.245);
            \path[draw, ->, color=blue] (cont.25) -| (11.5,0) |-
            (writebuf.345);
            \path[draw, ->, color=blue] (cont.15) -| (memread);
            \path[draw, ->, color=blue] (cont.5) -| (mem.55);
            \path[draw, ->, color=blue] (cont.355) -| (mem.125);
            \path[draw, ->, color=blue] (cont.335) -| (imm);
            \path[draw, ->, color=blue] (cont.325) -| (1.5, -4) |-
            (2, -5) -| (alucont.250);
            \path[draw, ->, color=blue] (cont.240) -| (regdst);

            \node[block] (clock) at (-7, -5.25) {Clock};
            \path[draw, ->, thick, color=green] (clock) -| (-9.5,0) |- (pc);
            \path[draw, ->, thick, color=green] (clock) -| (writebuf);
        \end{tikzpicture}
    }
    \caption{Simple single cycle MIPS processor. The units with | indicate
    multiplexors. The Clock is not an SME process, but has been added to
    emphasize which processes that are clocked.}
    \label{fig:simple-full}
\end{figure}
With all the components in place, wiring up the single cycle MIPS processor is
straightforward. We just need to declare the busses with the corresponding
names, and then SME handles the wiring process. Note that as previously
mentioned, the Write Buffer and the PC register should be clocked processes.
The wiring of the single cycle MIPS processor can be seen in Figure
\ref{fig:simple-full}.

\subsection{Writing the first program}
As mentioned before, the first single cycle MIPS processor should be able to
handle \texttt{add}, \texttt{sub}, \texttt{and}, \texttt{or}, \texttt{slt},
\texttt{sw}, \texttt{lw} and \texttt{beq}. As such, the first program should
consist of these. The program and the different parts of each of the
instructions can be seen in Table \ref{tab:first-program}.
\begin{table}
    \centering
    \begin{tabular}{rllllllll}
        \toprule
        Address & Instruction & opcode & rs & rt & rd/imm & shmt & funct & hex \\
        \midrule
        \texttt{0x00} & \texttt{add \$3 \$1 \$2} & \texttt{0x00} &
        \texttt{0x01} & \texttt{0x02} & \texttt{0x03} & \texttt{0x00} &
        \texttt{0x20} & \texttt{0x00221820} \\ % 5 + 2 = 7

        \texttt{0x04} & \texttt{sub \$4 \$3 \$2} & \texttt{0x00} &
        \texttt{0x03} & \texttt{0x02} & \texttt{0x04} & \texttt{0x00} &
        \texttt{0x22} & \texttt{0x00622022} \\ %  7 - 2 = 5

        \texttt{0x08} & \texttt{and \$5 \$3 \$1} & \texttt{0x00} &
        \texttt{0x03} & \texttt{0x03} & \texttt{0x05} & \texttt{0x00} &
        \texttt{0x24} & \texttt{0x00612824} \\ % 7 and 5 = 5

        \texttt{0x0C} & \texttt{and \$6 \$3 \$1} & \texttt{0x00} &
        \texttt{0x03} & \texttt{0x03} & \texttt{0x06} & \texttt{0x00} &
        \texttt{0x25} & \texttt{0x00613025} \\ % 7 or 5 = 7

        \texttt{0x10} & \texttt{slt \$7 \$6 \$5} & \texttt{0x00} &
        \texttt{0x06} & \texttt{0x05} & \texttt{0x07} & \texttt{0x00} &
        \texttt{0x2A} & \texttt{0x00C5382A} \\ % 7 < 5 = 1

        \texttt{0x14} & \texttt{sw \$6  0x0(\$0)} & \texttt{0x2B} &
        \texttt{0x00} & \texttt{0x06} & \texttt{0x0000} & - &
        - & \texttt{0xAC060000} \\ % M[0] = 7

        \texttt{0x18} & \texttt{lw \$8  0x0(\$0)} & \texttt{0x23} &
        \texttt{0x00} & \texttt{0x07} & \texttt{0x0000} & - &
        - & \texttt{0x8C070000} \\ % $8 = M[0] (= 7)

        \texttt{0x1C} & \texttt{beq \$5 \$4 0x4} & \texttt{0x04} &
        \texttt{0x05} & \texttt{0x04} & \texttt{0x0004} & - &
        - & \texttt{0x10A40004} \\ % if 5 == 5 then skip next

        \texttt{0x20} & \texttt{add \$9 \$8 \$6} & \texttt{0x00} &
        \texttt{0x08} & \texttt{0x06} & \texttt{0x09} & \texttt{0x00} &
        \texttt{0x20} & \texttt{0x01064820} \\ % 7 + 7 = 14 // should not run!

        \texttt{0x24} & \texttt{add \$10 \$8 \$6} & \texttt{0x00} &
        \texttt{0x08} & \texttt{0x06} & \texttt{0x0A} & \texttt{0x00} &
        \texttt{0x20} & \texttt{0x01065020} \\ % 7 + 7 = 14
        \bottomrule
    \end{tabular}
    \caption{The first MIPS program. Note that the instruction at \texttt{0x20}
    should be skipped due to the \texttt{beq} at \texttt{0x1C}.}
    \label{tab:first-program}
\end{table}

%TODO lav om til at læse fra en binary fil!
Inserting this program into the Instruction Memory is straightforward: just
create an \texttt{byte} array, which is initialized to the hex values from the
instruction column in Table \ref{tab:first-program}. Since we do not have any
way of feeding values into the Register File at this moment, we are going to
hardcode registers 1 and 2 with the values 5 and 2 respectively. When the
program has finished, the contents of the register file should be as in Table
\ref{tab:first-result}.
\begin{table}
    \centering
    \begin{tabular}{rrrrrrrrrrrrrrrrrrrr}
        \toprule
        Address & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
        \midrule
        Value & 0 & 5 & 2 & 7 & 5 & 5 & 7 & 1 & 7 & 0 & 14 \\
        \bottomrule
    \end{tabular}
    \caption{The register file after the first program has finished.}
    \label{tab:first-result}
\end{table}

\subsection{Extending the accepted instruction set}
\subsubsection*{Additional simple R format instructions}
The simplest instructions to add, are the remaining simple R format
instructions. These are \texttt{addu}, \texttt{subu}, \texttt{xor},
\texttt{nor} and \texttt{sltu}. The only modifications are to extend the ALU
Operation \texttt{enum}, and then add the remaining cases in the ALU Control
and the ALU. As described in section \ref{sec:alu}, it is important to cast the
input \texttt{uint} to \texttt{int} before making the computation, if the
operation is signed.

To test each of these instructions, we can just append them to our initial
program.

\subsubsection*{Immediate instructions}
The next instruction we want to add is the \texttt{ori} instruction, as this
would allow us to feed values into the processor without hardcoding it. While
we are doing this, we should also add \texttt{addi}, \texttt{addiu},
\texttt{slti}, \texttt{sltiu}, \texttt{andi} and \texttt{xori}, as these
requires the same amount of work.

For the logical immediates, it is important, that the Sign Extend does not
sign extend. As such, we add another signal to the Control Unit:
\texttt{LogicalImmediate}, which goes to the Sign Extend. The Sign Extend
should then, in the case the \texttt{LogicalImmediate} flag is \texttt{1}, cast
its input as \texttt{unsigned}, such that any potential sign bits are not
extended. Then we just need to extend the opcode and ALUOp \texttt{enum}, and
add the remaining \texttt{case}s in the Control Unit and the ALU Control.

Once the processor have been extended, we can prepend instructions at the
beginning of the program. Furthermore, we can remove our previous hardcoding of
initial values in the Register File.

\subsubsection*{Jump instruction}
We are going to introduce another format: the J format. This format is used for
executing the \texttt{j} instruction. The first step is to extend the Splitter,
as it should now send the lower 26 bits to the Jump Unit. Then the Control Unit
should be extended, both in the opcode \texttt{enum}, and it should have another
control signal output: \texttt{jump}, which should be connected to the Jump
Unit.

Finally, the Jump Unit should be extended. It should take the 26 bits from the
Splitter, and left shift it by 2, such that it becomes a 28 bit number. Then,
it should take the 4 most significant bits from the PC+4, and prepend them to
the extended number.  Finally, we are going to add a multiplexor, which takes
this newly computed address, the previous output address, and the \texttt{jump}
control signal. If the control signal is \texttt{0}, then the original output
should be output, otherwise the newly computed jump address.

Then the program can be extended with a \texttt{j} instruction, in the same
manner as the \texttt{beq} instruction was tested before, i.e. trying to jump
over some instructions.

\subsubsection*{Branching instructions}
Then we are going to add the remaining branching instructions \texttt{bne},
\texttt{blez} and \texttt{bgtz} instructions.

To implement the \texttt{bne} instruction, we are going to add another signal
from the Control Unit to the Jump Unit. Then we should split the Zero signal
into two, where one of the signals goes to a newly added \texttt{NOT} gate.
Then, we should add a multiplexor, which has the \texttt{bne} signal from the
Control Unit as the control signal, and the Zero and the \texttt{NOT} Zero as
inputs. If the \texttt{bne} control signal is \texttt{0}, then the original
Zero should be put on the output, otherwise the \texttt{NOT} Zero. The output
from the multiplexor should go into the \texttt{AND} gate, where the Zero
signal originally went.

TODO \texttt{blez}

TODO \texttt{bgtz}

\subsubsection*{Remaining jump instructions}
Then we are going to add the remaining jump instructions: \texttt{jr},
\texttt{jal} and \texttt{jalr}, as these are useful when writing the larger
programs later.

We start with \texttt{jr}. The instruction is in R format, so we do not know it
is \texttt{jr}, until it has reached the ALU Control. As such, we are going to
need a control signal from the ALU Control to the Jump Unit. We are also going
to forward Output A from the Register File to the Jump Unit, as this is the
address that the processor should jump to in the \texttt{jr} instruction. The
Jump Unit should not compute the new address in the same manner as with the
\texttt{j} instruction. This is due to the registers being a full 32 bit, and
thus can contain the whole address space. The Jump Unit should also have a
multiplexor, controlling whether the jump address should be the immediate
value, or if it should be the value from the instruction.

For the \texttt{jal} instruction, we are going to need an extra unit following
the ALU. In the case of a \texttt{jal} instruction, we should store the PC+4
address in register \texttt{31} (which is called the \texttt{\$ra} register).
There should be an additional control signal from the Control Unit: the
\texttt{jal} signal. The new JAL Unit should take three inputs: the ALU Result,
the PC+4 and the \texttt{jal} control signal. It should produce two outputs:
the Write Address for the Write Buffer, and the value to store. If the
\texttt{jal} signal is \texttt{1}, the JAL Unit should output the PC+4 on the
value bus, and \texttt{31} on the address bus. Otherwise it should output the
regular ALU Result, and the regular Write Address.

TODO \texttt{jalr}

\subsubsection*{Shift instructions}
Then we are going to add the shift instructions: \texttt{sll}, \texttt{slr},
\texttt{sra}, \texttt{sllv}, \texttt{srlv} and \texttt{srav}, as shifting is
often useful.

The shifting itself is performed in the ALU, and modifying the ALU to handle
these is straightforward. The problem is that in an R format instruction, which
the shift operations are, the shift amount (\texttt{shamt}) is stored in its
own field within the instruction. As such, the splitter should extract these 5
bits, and send them to a new multiplexor, which also takes Output A from the
Register File. As with the \texttt{jr} instruction, we do not know it is a
shifting instruction until it reaches the ALU Control. So to control the new
multiplexor, we need a Control signal from the ALU Control, indicating whether
the multiplexor should output either the \texttt{shamt} or Output A from the
Register File.

\subsubsection*{Multiplication and Division instructions}
Then we are going to add the multiplication and division instructions:
\texttt{mult}, \texttt{multu}, \texttt{div} and \texttt{divu}. All of these
instructions put their result in two special registers: HI and LO. As such, to
get the results from them, we are also going to need the \texttt{mfhi},
\texttt{mthi}, \texttt{mflo} and \texttt{mtlo} instructions.

We start by adding the special registers. Since they are performed in the ALU,
we might as well put them there. Then, when we are doing the computation, we
should just put the values there, and since the instructions do not write to
registers, touch memory or change the PC register, it does not matter what is
put on the ALU Result or Zero busses.

The instructions handling the moving to and from the HI and LO registers are
fairly simple to implement: just either input or output the corresponding
register, to or from the ALU.

The layout for the fully extended single cycle MIPS processor can be seen in
Figure \ref{fig:single-proc-full}

\begin{figure}
    \centering
    \scalebox{0.5}{
        \begin{tikzpicture}
            \node[block] (reg) at (0,0) {Register file};
            \node[control] (cont) at (-1,4.5) {Control unit};
            \node[block] (jump) at (5,6.5) {Jump unit};
            \node[empty] (splitspace) at (-3,0) {};
            \node[block] (split) at (-4,0) {Splitter};
            \node[block] (if) at (-7,0) {Instruction Memory};
            \node[block] (sign) at (-1,-3) {Sign extend};
            \node[block] (alu) at (4,0) {ALU};
            \node[block] (alucont) at (4,-4) {ALU control};
            \node[block] (mem) at (8.2,0) {Memory};
            \node[block] (jal) at (6,-0.22) {JAL};
            \node[mux] (memread) at (10,0) {|};
            \node[mux] (shmt) at (2,1.25) {|};
            \node[mux] (imm) at (3, -0.25) {|};
            \node[mux] (regdst) at (-2,-1) {|};
            \node[block] (pc) at (-8, 2) {PC};
            \node[block] (writebuf) at (6, -2) {Write buffer};

            \path[draw, ->] (if) -- (split);
            \path[draw, -] (split) -- (splitspace.center);
            \path[draw, ->] (splitspace.center) |- (sign);
            \path[draw, ->] (splitspace.center) |- (cont);
            \path[draw, ->] (splitspace.center) |- (reg.160);
            \path[draw, ->] (splitspace.center) |- (reg.200);
            \path[draw, ->] (splitspace.center) |- (jump.200);
            \path[draw, ->] (splitspace.center) |- (2,-5.5) -| (alucont.290);
            \path[draw, ->] (splitspace.center) |- (regdst.215);
            \path[draw, ->] (splitspace.center) |- (shmt.145);
            \path[draw, ->] (reg.200) -| (-2.5, -0.5) |- (regdst.145);
            \path[draw, ->, color=blue] (alucont) -| (12.5, 0) |- (jump);
            \path[draw, ->, color=blue] (alucont) -| (shmt);
            \path[draw, thick, ->] (reg.340) -| (2.25,-0.25) |- (imm.145);
            \path[draw, thick, ->] (2.25,-0.25) |- (3,0.75) -- (7,0.75) |-
            (mem.164);
            \path[draw, thick, ->] (reg.20) -| (1.25,0.5) |- (shmt.215);
            \path[draw, thick, -] (1.25,0.5) |- (4,2);
            \path[draw, thick, ->] (4,2) -| (jump.295);
            \path[draw, ->] (shmt) -| (2.5, 0.5) |- (alu.158);
            \path[draw, ->, dashed, color=blue] (alu.20) -| (jump);
            \path[draw, ->] (alu.340) -- (jal);
            \path[draw, ->] (jal) -- (mem.196);
            \path[draw, ->] (imm) -- (alu.202);
            \path[draw, ->] (7, -0.22) |- (8, -1) -| (9.25,-0.5) |-
            (memread.215);
            \path[draw, ->] (mem.10) -- (memread.145);
            \path[draw, ->] (sign) -| (2.5, -1) |- (imm.215);
            \path[draw, ->] (2.5,-3) -| (12, 0) |- (jump.340);
            \path[draw, thick, ->] (regdst) -| (5, -0.6) |- (jal.210);
            \path[draw, ->] (pc) -| (if);
            \path[draw, ->] (pc) -| (-4, 4) |- (jump);
            \path[draw, ->] (jump.160) -| (pc);
            \path[draw, ->] (jal) -- (writebuf);
            \path[draw, ->] (memread) -| (11, -1) |- (writebuf.15);
            \path[draw, dashed, ->] (writebuf.170) -| (reg.300);
            \path[draw, dashed, ->] (writebuf) -| (reg);
            \path[draw, dashed, ->, color=blue] (writebuf.190) -| (reg.240);

            \path[draw, ->, color=blue] (alucont) -- (alu);
            \path[draw, ->, color=blue] (cont.55) -| (jump.220);
            \path[draw, ->, color=blue] (cont.45) -| (jump.230);
            \path[draw, ->, color=blue] (cont.35) -| (jump.245);
            \path[draw, ->, color=blue] (cont.25) -| (11.5,0) |-
            (writebuf.345);
            \path[draw, ->, color=blue] (cont.15) -| (memread);
            \path[draw, ->, color=blue] (cont.5) -| (mem.55);
            \path[draw, ->, color=blue] (cont.355) -| (mem.125);
            \path[draw, ->, color=blue] (cont.345) -| (jal);
            \path[draw, ->, color=blue] (cont.335) -| (imm);
            %\path[draw, ->, color=blue] (cont.325) -| (shmt);
            \path[draw, ->, color=blue] (cont.325) -| (1.5, -4) |-
            (2, -5) -| (alucont.250);
            \path[draw, ->, color=blue] (cont.250) -- (sign.128);
            \path[draw, ->, color=blue] (cont.240) -| (regdst);

            \node[block] (clock) at (-7, -5.25) {Clock};
            \path[draw, ->, thick, color=green] (clock) -| (-9.5,0) |- (pc);
            \path[draw, ->, thick, color=green] (clock) -| (writebuf);
        \end{tikzpicture}
    }
    \caption{Full single cycle MIPS processor. The units with | indicate
    multiplexors. Black wires indicate data wires. Blue wires indicate control
    wires. Green wires indicate clock}
    \label{fig:single-proc-full}
\end{figure}
% TODO hertil!
\subsection{Larger MIPS programs}
To test the full single cycle MIPS processor, we are going to implement two
programs in MIPS assembly: Quicksort and Towers Of Hanoi. We choose these two
examples, as both are simple to implement, and they do not require anything
special from the environment.

We are not going to give the implementation in MIPS assembly, as this would not
be readable. Instead, we are going to construct some low level \texttt{C} code,
which should be easy translatable into MIPS assembly. Once we have made the
assembly, we can easily dump it into MARS, which can then produce a ascii hex
dump, which we can then paste into our instruction memory.

\subsubsection*{Quicksort}
There are three parts of the Quicksort program: Loading data into memory,
the partition function and the quicksort function. We are going to use the
simple partition function from the algorithm book\cite{ref:alg}, and the
quicksort function, also from the algorithm book.

We could have implemented the Hoare partitioning algorithm. However, we are
trying to keep the program itself as simple as possible, as performance is not
the target of the program, but rather correctness of the processor, i.e.  that
our processor implementation produce the same result as MARS.

\begin{description}
    \item[Loading data into memory] We start by loading data into memory, so
        that our quicksort program has some data to sort. Which numbers we are
        going to use is not important, rather the amount of numbers, as the
        quicksort algorithm uses it as argument. We construct a function
        called \texttt{load()}, which inserts 6 numbers into the given memory
        address.
        \begin{lstlisting}
 void load(int *a) {
    *(a)   = 5;
    *(a+1) = 8;
    *(a+2) = 2;
    *(a+3) = 9;
    *(a+4) = 1;
    *(a+5) = 3;
}\end{lstlisting}

    \item[The partitioning function] Then we implement the \texttt{partition()}
        function as described in the algorithm book\cite{ref:alg}. Note that
        statements in the book have been expanded to more closely resemble
        assembly.
\begin{lstlisting}
int partition(int *a, int p, int r) {
    int x, i, j, tmp1, tmp2, *addr1, *addr2;
    addr1 = a + r;
    x = *(addr1);
    i = p - 1;
    for (j = p; j < r; j++) {
        addr1 = a + j;
        if (*(addr1) <= x) {
            i++;
            addr1 = a + i;
            addr2 = a + j;
            tmp1 = *(addr1);
            tmp2 = *(addr2);
            *(addr1) = tmp2;
            *(addr2) = tmp1;
        }
    }
    addr1 = a + i + 1;
    addr2 = a + r;
    tmp1 = *(addr1);
    tmp2 = *(addr2);
    *(addr1) = tmp2;
    *(addr2) = tmp1;
    return i + 1;
}
\end{lstlisting}

    \item[The quicksort function] Finally, we implement the
        \texttt{quicksort()} function as described in the algorithms book.
\begin{lstlisting}
void quicksort(int *a, int p, int r) {
    if (p < r) {
        int q = partition(a, p, r);
        quicksort(a, p, q-1);
        quicksort(a, q+1, r);
    }
}
\end{lstlisting}

    \item[Initial call to the algorithm] Bla bla main function
\begin{lstlisting}
main()
\end{lstlisting}
\end{description}
Do note that the arguments to both the \texttt{quicksort()} and
\texttt{partition()} functions, are inclusive. To verify the correctness, we
should look at the memory, where the initial data now should be in sorted
order.

\subsubsection*{Towers Of Hanoi}
Towers Of Hanoi is a puzzle, where one has to move a tower of discs, from one
peg, to another, with one additional auxilary peg, by only moving one disk at
the time.

Usually when searching for Towers Of Hanoi implementations, the program just
prints which move to make. However, since our processor does not support
printing at this state, we modify it. We are going to represent the three pegs
as an array, which is three times the size of the tower. As such, each peg is
just one third of the array.

\begin{description}
    \item[Loading data into memory] We need to initialize the memory. We are
        just going to fill the first third of the array with descending
        numbers.
\begin{lstlisting}
void init(int num, int *from, int *to, int *aux) {
    int i;
    for (i = 0; i < num; i++) {
        *(from+i) = num - i;
        *(to+i) = 0;
        *(aux+i) = 0;
    }
}
\end{lstlisting}

    \item[The tower function] This is the \texttt{tower()} function, which
        moves the disks from peg to peg.
\begin{lstlisting}
void tower(int num, int **from, int **to, int **aux) {
    int *t, *f;
    if (num == 1) {
        t = *to;
        f = *from;
        f--;
        *t = *f;
        t++;
        *f = 0;
        *to = t;
        *from = f;
    } else {
        tower(num-1, from, aux, to);
        t = *to;
        f = *from;
        f--;
        *t = *f;
        t++;
        *f = 0;
        *to = t;
        *from = f;
        tower(num-1, aux, to, from);
    }
}
\end{lstlisting}

    \item[Calling the algorithm] We construct a \texttt{main()} function, to
        ensure that the algorithm is correct, and that it can be run in regular
        \texttt{C}.
\begin{lstlisting}
int main() {
    int num = 5;
    int *arr = int[num*3];
    init(num, arr, arr+num, arr+(2*num));
}
\end{lstlisting}
\end{description}
When the program has finished, the last third of the array should contain the
numbers in descending order.
