In this section, we will be combining the core components into a single cycle
MIPS processor, i.e. a processor where exactly one instruction is executed per
clock cycle. When it is in place, we will be writing the first program, and
compiling it into the processor, and running it.

Following the single cycle MIPS processor, we will be extending
the processor so that it can handle more instructions. Along each added
instruction, we will be extending our first program, in order to verify that
the instruction works.

Finally, we will be writing two larger programs, and look into compiling them
into a series of hex values, that we can copy straight into the Instruction
Memory.

\subsection{Wiring up the processor}
\begin{figure}
    \centering
    \scalebox{0.5}{
        \begin{tikzpicture}
            \node[block] (reg) at (0,0) {Register file};
            \node[control] (cont) at (-1,3.5) {Control unit};
            \node[block] (jump) at (5,5.5) {Jump unit};
            \node[empty] (splitspace) at (-3,0) {};
            \node[block] (split) at (-4,0) {Splitter};
            \node[block] (if) at (-7,0) {Instruction Memory};
            \node[block] (sign) at (-1,-3) {Sign extend};
            \node[block] (alu) at (4,0) {ALU};
            \node[block] (alucont) at (4,-4) {ALU control};
            \node[block] (mem) at (8.2,0) {Memory};
            \node[mux] (memread) at (10,0) {|};
            \node[mux] (imm) at (3, -0.25) {|};
            \node[mux] (regdst) at (-2,-1) {|};
            \node[block] (pc) at (-8, 2) {PC};
            \node[block] (writebuf) at (6, -2) {Write buffer};

            \path[draw, ->] (if) -- (split);
            \path[draw, -] (split) -- (splitspace.center);
            \path[draw, ->] (splitspace.center) |- (sign);
            \path[draw, ->] (splitspace.center) |- (cont);
            \path[draw, ->] (splitspace.center) |- (reg.160);
            \path[draw, ->] (splitspace.center) |- (reg.200);
            %\path[draw, ->] (splitspace.center) |- (alucont.200);
            \path[draw, ->] (splitspace.center) |- (2,-5.5) -| (alucont.290);
            \path[draw, ->] (splitspace.center) |- (regdst.215);
            \path[draw, ->] (reg.200) -| (-2.5, -0.5) |- (regdst.145);
            %\path[draw, ->] (alucont) -| (12.5, 0) |- (jump);
            \path[draw, thick, ->] (reg.340) -| (2,-0.25) |- (imm.145);
            \path[draw, thick, ->] (2,-0.25) |- (3,0.75) -- (7,0.75) |-
            (mem.164);
            \path[draw, ->] (reg.20) -- (alu.145);
            \path[draw, ->, dashed, color=blue] (alu.20) -| (jump);
            %\path[draw, ->] (alu.340) -- (jal);
            %\path[draw, ->] (jal) -- (mem.196);
            %\path[draw, ->] (jal) -- (writebuf);
            \path[draw, ->] (alu.340) -- (mem.195);
            \path[draw, ->] (imm) -- (alu.202);
            \path[draw, ->] (7, -0.22) |- (8, -1) -| (9.25,-0.5) |-
            (memread.215);
            \path[draw, ->] (mem.10) -- (memread.145);
            \path[draw, ->] (sign) -| (2.5, -1) |- (imm.215);
            \path[draw, ->] (2.5,-3) -| (12, 0) |- (jump.340);
            %\path[draw, thick, ->] (regdst) -| (5, -0.6) |- (jal.210);
            \path[draw, thick, ->] (regdst) -| (writebuf);
            \path[draw, ->] (pc) -| (if);
            \path[draw, ->] (pc) -| (-4, 4) |- (jump);
            \path[draw, ->] (jump.160) -| (pc);
            \path[draw, ->] (memread) -| (11, -1) |- (writebuf.15);
            \path[draw, dashed, ->] (writebuf.170) -| (reg.300);
            \path[draw, dashed, ->] (writebuf) -| (reg);
            \path[draw, dashed, ->, color=blue] (writebuf.190) -| (reg.240);

            \path[draw, ->, color=blue] (alucont) -- (alu);
            \path[draw, ->, color=blue] (cont.35) -| (jump.245);
            \path[draw, ->, color=blue] (cont.25) -| (11.5,0) |-
            (writebuf.345);
            \path[draw, ->, color=blue] (cont.15) -| (memread);
            \path[draw, ->, color=blue] (cont.5) -| (mem.55);
            \path[draw, ->, color=blue] (cont.355) -| (mem.125);
            \path[draw, ->, color=blue] (cont.335) -| (imm);
            \path[draw, ->, color=blue] (cont.325) -| (1.5, -4) |-
            (2, -5) -| (alucont.250);
            \path[draw, ->, color=blue] (cont.240) -| (regdst);

            \node[block] (clock) at (-7, -5.25) {Clock};
            \path[draw, ->, thick, color=green] (clock) -| (-9.5,0) |- (pc);
            \path[draw, ->, thick, color=green] (clock) -| (writebuf);
        \end{tikzpicture}
    }
    \caption{Simple single cycle MIPS processor. The units with | indicate
    multiplexors. The PC Unit is just a simple register.}
    \label{fig:simple-full}
\end{figure}
With all the components in place, wiring up the single cycle MIPS processor is
straightforward. We just need to declare the busses with the corresponding
names, and then SME handles the wiring process. Note that the Write Buffer and
the PC register should be clocked processes. The wiring og the single cycle
MIPS processor can be seen in Figure \ref{fig:simple-full}.

\subsection{Writing the first program}
As mentioned before, the first single cycle MIPS processor should be able to
handle \texttt{add}, \texttt{sub}, \texttt{and}, \texttt{or}, \texttt{slt},
\texttt{sw}, \texttt{lw} and \texttt{beq}. As such, the first program should be
testing these. The program and the different parts of the instructions can be
seen in Table \ref{tab:first-program}.
\begin{table}
    \centering
    \begin{tabular}{rllllllll}
        \toprule
        Address & Instruction & opcode & rs & rt & rd/imm & shmt & funct & hex \\
        \midrule
        \texttt{0x00} & \texttt{add \$3 \$1 \$2} & \texttt{0x00} &
        \texttt{0x01} & \texttt{0x02} & \texttt{0x03} & \texttt{0x00} &
        \texttt{0x20} & \texttt{0x00221820} \\ % 5 + 2 = 7

        \texttt{0x04} & \texttt{sub \$4 \$3 \$2} & \texttt{0x00} &
        \texttt{0x03} & \texttt{0x02} & \texttt{0x04} & \texttt{0x00} &
        \texttt{0x22} & \texttt{0x00622022} \\ %  7 - 2 = 5

        \texttt{0x08} & \texttt{and \$5 \$3 \$1} & \texttt{0x00} &
        \texttt{0x03} & \texttt{0x03} & \texttt{0x05} & \texttt{0x00} &
        \texttt{0x24} & \texttt{0x00612824} \\ % 7 and 5 = 5

        \texttt{0x0C} & \texttt{and \$6 \$3 \$1} & \texttt{0x00} &
        \texttt{0x03} & \texttt{0x03} & \texttt{0x06} & \texttt{0x00} &
        \texttt{0x25} & \texttt{0x00613025} \\ % 7 or 5 = 7

        \texttt{0x10} & \texttt{slt \$7 \$6 \$5} & \texttt{0x00} &
        \texttt{0x06} & \texttt{0x05} & \texttt{0x07} & \texttt{0x00} &
        \texttt{0x2A} & \texttt{0x00C5382A} \\ % 7 < 5 = 1

        \texttt{0x14} & \texttt{sw \$6  0x0(\$0)} & \texttt{0x2B} &
        \texttt{0x00} & \texttt{0x06} & \texttt{0x0000} & - &
        - & \texttt{0xAC060000} \\ % M[0] = 7

        \texttt{0x18} & \texttt{lw \$8  0x0(\$0)} & \texttt{0x23} &
        \texttt{0x00} & \texttt{0x07} & \texttt{0x0000} & - &
        - & \texttt{0x8C070000} \\ % $8 = M[0] (= 7)

        \texttt{0x1C} & \texttt{beq \$5 \$4 0x4} & \texttt{0x04} &
        \texttt{0x05} & \texttt{0x04} & \texttt{0x0004} & - &
        - & \texttt{0x10A40004} \\ % if 5 == 5 then skip next

        \texttt{0x20} & \texttt{add \$9 \$8 \$6} & \texttt{0x00} &
        \texttt{0x08} & \texttt{0x06} & \texttt{0x09} & \texttt{0x00} &
        \texttt{0x20} & \texttt{0x01064820} \\ % 7 + 7 = 14 // should not run!

        \texttt{0x24} & \texttt{add \$10 \$8 \$6} & \texttt{0x00} &
        \texttt{0x08} & \texttt{0x06} & \texttt{0x0A} & \texttt{0x00} &
        \texttt{0x20} & \texttt{0x01065020} \\ % 7 + 7 = 14
        \bottomrule
    \end{tabular}
    \caption{The first MIPS program. Note that the instruction at \texttt{0x20}
    should be skipped.}
    \label{tab:first-program}
\end{table}

Inserting this program into the Instruction Memory is straightforward: just
create an \texttt{uint} array, which is initialized to the hex values from
Table \ref{tab:first-program}. Since we do not have any way of feeding values
into the Register File at this moment, we are going to hardcode registers 1 and
2 with the values 5 and 2 respectively. When the program has finished, the
contents of the register file should be as in Table \ref{tab:first-result}.
\begin{table}
    \centering
    \begin{tabular}{rrrrrrrrrrrrrrrrrrrr}
        \toprule
        Address & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
        \midrule
        Value & 0 & 5 & 2 & 7 & 5 & 5 & 7 & 1 & 7 & 0 & 14 \\
        \bottomrule
    \end{tabular}
    \caption{The register file after the first program has finished.}
    \label{tab:first-result}
\end{table}

\subsection{Extending the accepted instruction set}
\subsubsection*{Additional simple R format instructions}
The simplest instructions to add, are the remaining simple R format
instructions. These are \texttt{addu}, \texttt{subu}, \texttt{xor},
\texttt{nor} and \texttt{sltu}. The only modifications are in the ALU Control
and the ALU. For the unsigned instructions, it is important to remember to cast
before making the computation.

Testing these new instructions is straightforward: just append them to the
simple program.

\subsubsection*{Immediate instructions}
The next instruction we want to add is the \texttt{addi} instruction, as this
would allow us to feed values into the processor without hardcoding it. While
we are doing this, we should also add \texttt{addiu}, \texttt{slti},
\texttt{sltiu}, \texttt{andi}, \texttt{ori} and \texttt{xori}, as these
requires the same amount of work.

For the logical immediates, it is important, that the Sign Extend does not
sign extend. As such, we add another signal to the Control Unit:
\texttt{LogicalImmediate}, which goes to the Sign Extend. The Sign Extend
should then, in the case the \texttt{LogicalImmediate} flag is \texttt{1}, cast
its input as \texttt{unsigned}, such that any potential sign bits are not
extended. Then, all we need to do, is extend the \texttt{enum}s and the
\texttt{switch}es. The affected units are: The Control Unit, the ALU Control
and the ALU.

Once the processor have been extended, we can prepend instructions at the
beginning of the program, in order to insert initial values into the Register
File, and then it is just adding each instruction, and verifying the output in
the Register File.

\subsubsection*{Jump instruction}
We are going to introduce another format: the J format. This format is used for
executing the \texttt{j} instruction. The first step is to extend the Splitter,
as it should now send the first 26 bits to the Jump Unit. Then the Control Unit
should be extended, both in its \texttt{enum}, and it should have another
control signal output: \texttt{jump}, which should be connected to the Jump
Unit.

Finally, the Jump Unit should be extended. It should take the 26 bits from the
Splitter, and left shift it by 2, such that it becomes a 28 bit number. Then,
it should take the 4 most significant bits from the PC+4, and prepend them to
the extended number.  Finally, we are going to add a multiplexor, which takes
this newly computed address, the previous output address, and the \texttt{jump}
control signal. If the control signal is \texttt{0}, then the original output
should be output, otherwise the newly computed jump address.

Then the program can be extended with a \texttt{j} instruction, in the same
manner as the \texttt{beq} instruction was tested before.

\subsubsection*{Branching instructions}
Then we are going to add the \texttt{bne}, \texttt{blez} and \texttt{bgtz}
instructions.

To implement the \texttt{bne} instruction, we are going to add another signal
from the Control Unit to the Jump Unit. Then we should split the Zero signal
into two, where one of the signals goes to a newly added \texttt{NOT} gate.
Then, we should add a multiplexor, which has the \texttt{bne} signal from the
Control Unit as the control signal, and the Zero and the \texttt{NOT} Zero as
inputs. If the control signal is \texttt{0}, then the original Zero should be
put on the output, otherwise the \texttt{NOT} Zero.  The output from the
multiplexor should go into the \texttt{AND} gate, where the Zero signal
originally went.

TODO \texttt{blez}

TODO \texttt{bgtz}

\subsubsection*{Remaining jump instructions}
Then we are going to add the \texttt{jr}, \texttt{jal} and \texttt{jalr}
instructions, as these are useful when writing the larger programs later.

We start with \texttt{jr}. The instruction is in R format, so we do not know it
is \texttt{jr}, until it has reached the ALU Control. As such, we are going to
need a control signal from the ALU Control to the Jump Unit. We are also going
to forward Output A from the Register File to the Jump Unit, as this is the
address that the processor should jump to in the \texttt{jr} instruction. The
Jump Unit should then compute the new address in the same manner as usual, and
have a multiplexor, controlling whether the jump address should be the
immediate value, or if it should be the value from the instruction.

For the \texttt{jal} instruction, we are going to need an extra unit following
the ALU. In the case of a \texttt{jal} instruction, we should store the PC+4
address in register \texttt{31} (which is called the \texttt{\$ra} register).
There should be an additional control signal from the Control Unit: the
\texttt{jal} signal. The new JAL Unit should take three inputs: the ALU Result,
the PC+4 and the \texttt{jal} control signal. It should produce two outputs:
the Write Address for the Write Buffer, and the value to store. If the
\texttt{jal} signal is \texttt{1}, the JAL Unit should output the PC+4 on the
value bus, and \texttt{31} on the address bus. Otherwise it should output the
regular ALU Result, and the regular Write Address.

TODO \texttt{jalr}

\subsubsection*{Shift instructions}
Then we are going to add the \texttt{sll}, \texttt{slr}, \texttt{sra},
\texttt{sllv}, \texttt{srlv} and \texttt{srav} instructions, as shifting is
often useful.

The shifting itself is performed in the ALU, and modifying the ALU to handle
these is straightforward. The problem is that in an R format instruction, which
the shift operations are, the shift amount (\texttt{shamt}) is stored in its
own field within the instruction. As such, the splitter should extract these 5
bits, and send them to a new multiplexor, which also takes Output A from the
Register File. As with the \texttt{jr} instruction, we do not know it is a
shifting instruction until it reaches the ALU Control. So to control the new
multiplexor, we need a Control signal from the ALU Control, indicating whether
the multiplexor should output either the \texttt{shamt} or Output A from the
Register File.

\subsubsection*{Multiplication and Division instructions}
Then we are going to add the \texttt{mult}, \texttt{multu}, \texttt{div} and
\texttt{divu} instructions. All of these instructions put their result in two
special registers: HI and LO. As such, to get the results from them, we are
also going to need the \texttt{mfhi}, \texttt{mthi}, \texttt{mflo} and
\texttt{mtlo} instructions.

We start by adding the special registers. Since they are performed in the ALU,
we might as well put them there. Then, when we are doing the computation, we
should just put the values there, and since the instructions do not write to
registers, touch memory or change the PC register, it does not matter what is
put on the ALU Result or Zero busses.

The instructions handling the moving to and from the HI and LO registers are
fairly simple to implement: just either input or output the corresponding
register.

The layout for the fully extended single cycle MIPS processor can be seen in
Figure \ref{fig:single-proc-full}

\begin{figure}
    \centering
    \scalebox{0.5}{
        \begin{tikzpicture}
            \node[block] (reg) at (0,0) {Register file};
            \node[control] (cont) at (-1,4.5) {Control unit};
            \node[block] (jump) at (5,6.5) {Jump unit};
            \node[empty] (splitspace) at (-3,0) {};
            \node[block] (split) at (-4,0) {Splitter};
            \node[block] (if) at (-7,0) {Instruction Memory};
            \node[block] (sign) at (-1,-3) {Sign extend};
            \node[block] (alu) at (4,0) {ALU};
            \node[block] (alucont) at (4,-4) {ALU control};
            \node[block] (mem) at (8.2,0) {Memory};
            \node[block] (jal) at (6,-0.22) {JAL};
            \node[mux] (memread) at (10,0) {|};
            \node[mux] (shmt) at (2,1.25) {|};
            \node[mux] (imm) at (3, -0.25) {|};
            \node[mux] (regdst) at (-2,-1) {|};
            \node[block] (pc) at (-8, 2) {PC};
            \node[block] (writebuf) at (6, -2) {Write buffer};

            \path[draw, ->] (if) -- (split);
            \path[draw, -] (split) -- (splitspace.center);
            \path[draw, ->] (splitspace.center) |- (sign);
            \path[draw, ->] (splitspace.center) |- (cont);
            \path[draw, ->] (splitspace.center) |- (reg.160);
            \path[draw, ->] (splitspace.center) |- (reg.200);
            \path[draw, ->] (splitspace.center) |- (jump.200);
            \path[draw, ->] (splitspace.center) |- (2,-5.5) -| (alucont.290);
            \path[draw, ->] (splitspace.center) |- (regdst.215);
            \path[draw, ->] (splitspace.center) |- (shmt.145);
            \path[draw, ->] (reg.200) -| (-2.5, -0.5) |- (regdst.145);
            \path[draw, ->, color=blue] (alucont) -| (12.5, 0) |- (jump);
            \path[draw, ->, color=blue] (alucont) -| (shmt);
            \path[draw, thick, ->] (reg.340) -| (2.25,-0.25) |- (imm.145);
            \path[draw, thick, ->] (2.25,-0.25) |- (3,0.75) -- (7,0.75) |-
            (mem.164);
            \path[draw, thick, ->] (reg.20) -| (1.25,0.5) |- (shmt.215);
            \path[draw, thick, -] (1.25,0.5) |- (4,2);
            \path[draw, thick, ->] (4,2) -| (jump.295);
            \path[draw, ->] (shmt) -| (2.5, 0.5) |- (alu.158);
            \path[draw, ->, dashed, color=blue] (alu.20) -| (jump);
            \path[draw, ->] (alu.340) -- (jal);
            \path[draw, ->] (jal) -- (mem.196);
            \path[draw, ->] (imm) -- (alu.202);
            \path[draw, ->] (7, -0.22) |- (8, -1) -| (9.25,-0.5) |-
            (memread.215);
            \path[draw, ->] (mem.10) -- (memread.145);
            \path[draw, ->] (sign) -| (2.5, -1) |- (imm.215);
            \path[draw, ->] (2.5,-3) -| (12, 0) |- (jump.340);
            \path[draw, thick, ->] (regdst) -| (5, -0.6) |- (jal.210);
            \path[draw, ->] (pc) -| (if);
            \path[draw, ->] (pc) -| (-4, 4) |- (jump);
            \path[draw, ->] (jump.160) -| (pc);
            \path[draw, ->] (jal) -- (writebuf);
            \path[draw, ->] (memread) -| (11, -1) |- (writebuf.15);
            \path[draw, dashed, ->] (writebuf.170) -| (reg.300);
            \path[draw, dashed, ->] (writebuf) -| (reg);
            \path[draw, dashed, ->, color=blue] (writebuf.190) -| (reg.240);

            \path[draw, ->, color=blue] (alucont) -- (alu);
            \path[draw, ->, color=blue] (cont.55) -| (jump.220);
            \path[draw, ->, color=blue] (cont.45) -| (jump.230);
            \path[draw, ->, color=blue] (cont.35) -| (jump.245);
            \path[draw, ->, color=blue] (cont.25) -| (11.5,0) |-
            (writebuf.345);
            \path[draw, ->, color=blue] (cont.15) -| (memread);
            \path[draw, ->, color=blue] (cont.5) -| (mem.55);
            \path[draw, ->, color=blue] (cont.355) -| (mem.125);
            \path[draw, ->, color=blue] (cont.345) -| (jal);
            \path[draw, ->, color=blue] (cont.335) -| (imm);
            %\path[draw, ->, color=blue] (cont.325) -| (shmt);
            \path[draw, ->, color=blue] (cont.325) -| (1.5, -4) |-
            (2, -5) -| (alucont.250);
            \path[draw, ->, color=blue] (cont.250) -- (sign.128);
            \path[draw, ->, color=blue] (cont.240) -| (regdst);

            \node[block] (clock) at (-7, -5.25) {Clock};
            \path[draw, ->, thick, color=green] (clock) -| (-9.5,0) |- (pc);
            \path[draw, ->, thick, color=green] (clock) -| (writebuf);
        \end{tikzpicture}
    }
    \caption{Full single cycle MIPS processor. The units with | indicate
    multiplexors. Black wires indicate data wires. Blue wires indicate control
    wires. Green wires indicate clock}
    \label{fig:single-proc-full}
\end{figure}

\subsection{Larger MIPS programs}
To test the full single cycle MIPS processor, we are going to implement two
programs in MIPS assembly: Quicksort and Towers Of Hanoi. We are going to
construct some low level \texttt{C} code, which should be easy translatable
into assembly. Once we have made the assembly, we can easily dump it into MARS,
which can then produce a ascii hex dump, which we can then paste into our
instruction memory.

\subsubsection*{Quicksort}
There are three parts of the Quicksort program: Loading data into memory,
the partition function and the quicksort function. We are going to use Hoare
partition as our partition function, and the quicksort function as described in
the algorithm book.

\begin{lstlisting}
void load(int *a) {
    *(a)   = 5;
    *(a+1) = 8;
    *(a+2) = 2;
    *(a+3) = 9;
    *(a+4) = 1;
    *(a+5) = 3;
}

int partition(int *a, int p, int r) {
    int x, i, j, *addr1, *addr2, val1, val2;
    x = *(a + p);
    i = p - 1;
    j = r + 1;
    while (true) {
        do {
            j--;
            addr1 = a + j;
            val1 = *(addr1);
        } while (val1 > x);
        do {
            i++;
            addr2 = a + i;
            val2 = *(addr2);
        } while (val2 < x);
        if (i < j) {
            *(addr1) = val2;
            *(addr2) = val1;
        } else {
            return j;
        }
    }
}

void quicksort(int *a, int p, int r) {
    if (p < r) {
        int q = partition(a, p, r);
        quicksort(a, p, q);
        quicksort(a, q+1, r);
    }
}

int main() {
    int arr[6];
    load(arr);
    quicksort(arr, 0, 5);
}
\end{lstlisting}

\subsubsection*{Towers Of Hanoi}
Towers Of Hanoi is a puzzle, where one has to move a tower of discs, from one
peg, to another, with one additional auxilary peg, by only moving one disk at
the time. We are going to represent the three pegs as an array, which is three
times the size of the tower.

\begin{lstlisting}
void init(int num, int *from, int *to, int *aux) {
    int i;
    for (i = 0; i < num; i++) {
        *(from+i) = num - i;
        *(to+i) = 0;
        *(aux+i) = 0;
    }
}

void tower(int num, int **from, int **to, int **aux) {
    int *t, *f;
    if (num == 1) {
        t = *to;
        f = *from;
        f--;
        *t = *f;
        t++;
        *f = 0;
        *to = t;
        *from = f;
    } else {
        tower(num-1, from, aux, to);
        t = *to;
        f = *from;
        f--;
        *t = *f;
        t++;
        *f = 0;
        *to = t;
        *from = f;
        tower(num-1, aux, to, from);
    }
}

int main() {
    int num = 5;
    int *arr = int[num*3];
    init(num, arr, arr+num, arr+(2*num));
}
\end{lstlisting}
