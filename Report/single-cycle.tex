In this section, we will be combining the core components into a single cycle
MIPS processor, i.e. a processor where exactly one instruction is executed per
clock cycle. When it is in place, we will be writing the first program, and
compiling it into the processor, and running it.

Following the single cycle MIPS processor, we will be extending
the processor so that it can handle more instructions. Along each added
instruction, we will be extending our first program, in order to verify that
the instruction works.

Finally, we will be writing two larger programs, and look into compiling them
into a series of hex values, that we can copy straight into the Instruction
Memory.

\subsection{Wiring up the processor}
\begin{figure}
    \centering
    \scalebox{0.5}{
        \begin{tikzpicture}
            \node[block] (reg) at (0,0) {Register file};
            \node[control] (cont) at (-1,3.5) {Control unit};
            \node[block] (jump) at (5,5.5) {Jump unit};
            \node[empty] (splitspace) at (-3,0) {};
            \node[block] (split) at (-4,0) {Splitter};
            \node[block] (if) at (-7,0) {Instruction Memory};
            \node[block] (sign) at (-1,-3) {Sign extend};
            \node[block] (alu) at (4,0) {ALU};
            \node[block] (alucont) at (4,-4) {ALU control};
            \node[block] (mem) at (8.2,0) {Memory};
            \node[mux] (memread) at (10,0) {|};
            \node[mux] (imm) at (3, -0.25) {|};
            \node[mux] (regdst) at (-2,-1) {|};
            \node[block] (pc) at (-8, 2) {PC};
            \node[block] (writebuf) at (6, -2) {Write buffer};

            \path[draw, ->] (if) -- (split);
            \path[draw, -] (split) -- (splitspace.center);
            \path[draw, ->] (splitspace.center) |- (sign);
            \path[draw, ->] (splitspace.center) |- (cont);
            \path[draw, ->] (splitspace.center) |- (reg.160);
            \path[draw, ->] (splitspace.center) |- (reg.200);
            \path[draw, ->] (splitspace.center) |- (alucont.200);
            \path[draw, ->] (splitspace.center) |- (regdst.215);
            \path[draw, ->] (reg.200) -| (-2.5, -0.5) |- (regdst.145);
            %\path[draw, ->] (alucont) -| (12.5, 0) |- (jump);
            \path[draw, thick, ->] (reg.340) -| (2,-0.25) |- (imm.145);
            \path[draw, thick, ->] (2,-0.25) |- (3,0.75) -- (7,0.75) |-
            (mem.164);
            \path[draw, ->] (reg.20) -- (alu.145);
            \path[draw, ->] (alu.20) -| (jump);
            %\path[draw, ->] (alu.340) -- (jal);
            %\path[draw, ->] (jal) -- (mem.196);
            %\path[draw, ->] (jal) -- (writebuf);
            \path[draw, ->] (alu.340) -- (mem.195);
            \path[draw, ->] (imm) -- (alu.202);
            \path[draw, ->] (7, -0.22) |- (8, -1) -| (9.25,-0.5) |-
            (memread.215);
            \path[draw, ->] (mem.10) -- (memread.145);
            \path[draw, ->] (sign) -| (2.5, -1) |- (imm.215);
            \path[draw, ->] (2.5,-3) -| (12, 0) |- (jump.340);
            %\path[draw, thick, ->] (regdst) -| (5, -0.6) |- (jal.210);
            \path[draw, thick, ->] (regdst) -| (writebuf);
            \path[draw, ->] (pc) -| (if);
            \path[draw, ->] (pc) -| (-4, 4) |- (jump);
            \path[draw, ->] (jump.160) -| (pc);
            \path[draw, ->] (memread) -| (11, -1) |- (writebuf.15);
            \path[draw, dashed, ->] (writebuf.170) -| (reg.300);
            \path[draw, dashed, ->] (writebuf) -| (reg);
            \path[draw, dashed, ->, color=blue] (writebuf.190) -| (reg.240);

            \path[draw, ->, color=blue] (alucont) -- (alu);
            \path[draw, ->, color=blue] (cont.35) -| (jump.245);
            \path[draw, ->, color=blue] (cont.25) -| (11.5,0) |-
            (writebuf.345);
            \path[draw, ->, color=blue] (cont.15) -| (memread);
            \path[draw, ->, color=blue] (cont.5) -| (mem.55);
            \path[draw, ->, color=blue] (cont.355) -| (mem.125);
            \path[draw, ->, color=blue] (cont.335) -| (imm);
            \path[draw, ->, color=blue] (cont.315) -| (1.5, 0.5) |-
            (alucont.160);
            \path[draw, ->, color=blue] (cont.240) -| (regdst);

            \node[block] (clock) at (-7, -5) {Clock};
            \path[draw, ->, thick, color=green] (clock) -- (if);
            \path[draw, ->, thick, color=green] (clock) -| (writebuf);
        \end{tikzpicture}
    }
    \caption{Simple single cycle MIPS processor. The units with | indicate
    multiplexors. The PC Unit is just a simple register.}
    \label{fig:simple-full}
\end{figure}
With all the components in place, wiring up the single cycle MIPS processor is
straightforward. We just need to declare the busses with the corresponding
names, and then SME handles the wiring process. Note that the Write Buffer and
the PC register should be clocked processes. The wiring og the single cycle
MIPS processor can be seen in Figure \ref{fig:simple-full}.

\subsection{Writing the first program}
As mentioned before, the first single cycle MIPS processor should be able to
handle \texttt{add}, \texttt{sub}, \texttt{and}, \texttt{or}, \texttt{slt},
\texttt{sw}, \texttt{lw} and \texttt{beq}. As such, the first program should be
testing these. The program and the different parts of the instructions can be
seen in Table \ref{tab:first-program}.
\begin{table}
    \centering
    \begin{tabular}{rllllllll}
        \toprule
        Address & Instruction & opcode & rs & rt & rd/imm & shmt & funct & hex \\
        \midrule
        \texttt{0x00} & \texttt{add \$3 \$1 \$2} & \texttt{0x00} &
        \texttt{0x01} & \texttt{0x02} & \texttt{0x03} & \texttt{0x00} &
        \texttt{0x20} & \texttt{0x00221820} \\ % 5 + 2 = 7

        \texttt{0x04} & \texttt{sub \$4 \$3 \$2} & \texttt{0x00} &
        \texttt{0x03} & \texttt{0x02} & \texttt{0x04} & \texttt{0x00} &
        \texttt{0x22} & \texttt{0x00622022} \\ %  7 - 2 = 5

        \texttt{0x08} & \texttt{and \$5 \$3 \$1} & \texttt{0x00} &
        \texttt{0x03} & \texttt{0x03} & \texttt{0x05} & \texttt{0x00} &
        \texttt{0x24} & \texttt{0x00612824} \\ % 7 and 5 = 5

        \texttt{0x0C} & \texttt{and \$6 \$3 \$1} & \texttt{0x00} &
        \texttt{0x03} & \texttt{0x03} & \texttt{0x06} & \texttt{0x00} &
        \texttt{0x25} & \texttt{0x00613025} \\ % 7 or 5 = 7

        \texttt{0x10} & \texttt{slt \$7 \$6 \$5} & \texttt{0x00} &
        \texttt{0x06} & \texttt{0x05} & \texttt{0x07} & \texttt{0x00} &
        \texttt{0x2A} & \texttt{0x00C5382A} \\ % 7 < 5 = 1

        \texttt{0x14} & \texttt{sw \$6  0x0(\$0)} & \texttt{0x2B} &
        \texttt{0x00} & \texttt{0x06} & \texttt{0x0000} & - &
        - & \texttt{0xAC060000} \\ % M[0] = 7

        \texttt{0x18} & \texttt{lw \$8  0x0(\$0)} & \texttt{0x23} &
        \texttt{0x00} & \texttt{0x07} & \texttt{0x0000} & - &
        - & \texttt{0x8C070000} \\ % $8 = M[0] (= 7)

        \texttt{0x1C} & \texttt{beq \$5 \$4 0x4} & \texttt{0x04} &
        \texttt{0x05} & \texttt{0x04} & \texttt{0x0004} & - &
        - & \texttt{0x10A40004} \\ % if 5 == 5 then skip next

        \texttt{0x20} & \texttt{add \$9 \$8 \$6} & \texttt{0x00} &
        \texttt{0x08} & \texttt{0x06} & \texttt{0x09} & \texttt{0x00} &
        \texttt{0x20} & \texttt{0x01064820} \\ % 7 + 7 = 14 // should not run!

        \texttt{0x24} & \texttt{add \$10 \$8 \$6} & \texttt{0x00} &
        \texttt{0x08} & \texttt{0x06} & \texttt{0x0A} & \texttt{0x00} &
        \texttt{0x20} & \texttt{0x01065020} \\ % 7 + 7 = 14
        \bottomrule
    \end{tabular}
    \caption{The first MIPS program. Note that the instruction at \texttt{0x20}
    should be skipped.}
    \label{tab:first-program}
\end{table}

Inserting this program into the Instruction Memory is straightforward: just
create an \texttt{uint} array, which is initialized to the hex values from
Table \ref{tab:first-program}. Since we do not have any way of feeding values
into the Register File at this moment, we are going to hardcode registers 1 and
2 with the values 5 and 2 respectively. When the program has finished, the
contents of the register file should be as in Table \ref{tab:first-result}.
\begin{table}
    \centering
    \begin{tabular}{rrrrrrrrrrrrrrrrrrrr}
        \toprule
        Address & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
        \midrule
        Value & 0 & 5 & 2 & 7 & 5 & 5 & 7 & 1 & 7 & 0 & 14 \\
        \bottomrule
    \end{tabular}
    \caption{The register file after the first program has finished.}
    \label{tab:first-result}
\end{table}

\subsection{Extending the accepted instruction set}
\subsubsection*{Additional simple R format instructions}
The simplest instructions to add, are the remaining simple R format
instructions. These are \texttt{addu}, \texttt{subu}, \texttt{xor},
\texttt{nor} and \texttt{sltu}. The only modifications are in the ALU Control
and the ALU. For the unsigned instructions, it is important to remember to cast
before making the computation.

Testing these new instructions is straightforward: just append them to the
simple program.

\subsubsection*{Immediate instructions}
The next instruction we want to add is the \texttt{addi} instruction, as this
would allow us to feed values into the processor without hardcoding it. While
we are doing this, we should also add \texttt{addiu}, \texttt{slti},
\texttt{sltiu}, \texttt{andi}, \texttt{ori} and \texttt{xori}, as these
requires the same amount of work.

For the logical immediates, it is important, that the Sign Extend does not
sign extend. As such, we add another signal to the Control Unit:
\texttt{LogicalImmediate}, which goes to the Sign Extend. The Sign Extend
should then, in the case the \texttt{LogicalImmediate} flag is \texttt{1}, cast
its input as \texttt{unsigned}, such that any potential sign bits are not
extended. Then, all we need to do, is extend the \texttt{enum}s and the
\texttt{switch}es. The affected units are: The Control Unit, the ALU Control
and the ALU.

Once the processor have been extended, we can prepend instructions at the
beginning of the program, in order to insert initial values into the Register
File, and then it is just adding each instruction, and verifying the output in
the Register File.

\subsubsection*{Jump instruction}
We are going to introduce another format: the J format. This format is used for
executing the \texttt{j} instruction. The first step is to extend the Splitter,
as it should now send the first 26 bits to the Jump Unit. Then the Control Unit
should be extended, both in its \texttt{enum}, and it should have another
control signal output: \texttt{jump}, which should be connected to the Jump
Unit.

Finally, the Jump Unit should be extended. It should take the 26 bits from the
Splitter, and left shift it by 2, such that it becomes a 28 bit number. Then,
it should take the 4 most significant bits from the PC+4, and prepend them to
the extended number.  Finally, we are going to add a multiplexor, which takes
this newly computed address, the previous output address, and the \texttt{jump}
control signal. If the control signal is \texttt{0}, then the original output
should be output, otherwise the newly computed jump address.

Then the program can be extended with a \texttt{j} instruction, in the same
manner as the \texttt{beq} instruction was tested before.

\subsubsection*{Branching instructions}
Then we are going to add the \texttt{bne}, \texttt{blez} and \texttt{bgtz}
instructions.

To implement the \texttt{bne} instruction, we are going to add another signal
from the Control Unit to the Jump Unit. Then we should split the Zero signal
into two, where one of the signals goes to a newly added \texttt{NOT} gate.
Then, we should add a multiplexor, which has the \texttt{bne} signal from the
Control Unit as the control signal, and the Zero and the \texttt{NOT} Zero as
inputs. If the control signal is \texttt{0}, then the original Zero should be
put on the output, otherwise the \texttt{NOT} Zero.  The output from the
multiplexor should go into the \texttt{AND} gate, where the Zero signal
originally went.

TODO \texttt{blez}

TODO \texttt{bgtz}

\subsubsection*{Remaining jump instructions}
\texttt{jr}, \texttt{jal} and \texttt{jalr}

\subsubsection*{Shift instructions}
\texttt{sll}, \texttt{slr}, \texttt{sra}, \texttt{sllv}, \texttt{srlv} and
\texttt{srav}

\subsubsection*{Multiplication and Division instructions}
\texttt{mult}, \texttt{multu}, \texttt{div}, \texttt{divu}, \texttt{mfhi},
\texttt{mthi}, \texttt{mflo} and \texttt{mtlo}.

\begin{figure}
    \centering
    \scalebox{0.5}{
        \begin{tikzpicture}
            \node[block] (reg) at (0,0) {Register file};
            \node[control] (cont) at (-1,3.5) {Control unit};
            \node[block] (jump) at (5,5.5) {Jump unit};
            \node[empty] (splitspace) at (-3,0) {};
            \node[block] (split) at (-4,0) {Splitter};
            \node[block] (if) at (-7,0) {Instruction Memory};
            \node[block] (sign) at (-1,-3) {Sign extend};
            \node[block] (alu) at (4,0) {ALU};
            \node[block] (alucont) at (4,-4) {ALU control};
            \node[block] (mem) at (8.2,0) {Memory};
            \node[block] (jal) at (6,-0.22) {JAL};
            \node[mux] (memread) at (10,0) {|};
            \node[mux] (shmt) at (2,1.25) {|};
            \node[mux] (imm) at (3, -0.25) {|};
            \node[mux] (regdst) at (-2,-1) {|};
            \node[block] (pc) at (-8, 2) {PC};
            \node[block] (writebuf) at (6, -2) {Write buffer};

            \path[draw, ->] (if) -- (split);
            \path[draw, -] (split) -- (splitspace.center);
            \path[draw, ->] (splitspace.center) |- (sign);
            \path[draw, ->] (splitspace.center) |- (cont);
            \path[draw, ->] (splitspace.center) |- (reg.160);
            \path[draw, ->] (splitspace.center) |- (reg.200);
            \path[draw, ->] (splitspace.center) |- (jump.200);
            \path[draw, ->] (splitspace.center) |- (alucont.200);
            \path[draw, ->] (splitspace.center) |- (regdst.215);
            \path[draw, ->] (splitspace.center) |- (shmt.145);
            \path[draw, ->] (reg.200) -| (-2.5, -0.5) |- (regdst.145);
            \path[draw, ->] (alucont) -| (12.5, 0) |- (jump);
            \path[draw, thick, ->] (reg.340) -| (2,-0.25) |- (imm.145);
            \path[draw, thick, ->] (2,-0.25) |- (3,0.75) -- (7,0.75) |-
            (mem.164);
            \path[draw, thick, ->] (reg.20) -| (1.25,0.5) |- (shmt.215);
            \path[draw, thick, -] (1.25,0.5) |- (4,2);
            \path[draw, thick, ->] (4,2) -| (jump.295);
            \path[draw, ->] (shmt) -| (2.5, 0.5) |- (alu.158);
            \path[draw, ->] (alu.20) -| (jump);
            \path[draw, ->] (alu.340) -- (jal);
            \path[draw, ->] (jal) -- (mem.196);
            \path[draw, ->] (imm) -- (alu.202);
            \path[draw, ->] (7, -0.22) |- (8, -1) -| (9.25,-0.5) |-
            (memread.215);
            \path[draw, ->] (mem.10) -- (memread.145);
            \path[draw, ->] (sign) -| (2.5, -1) |- (imm.215);
            \path[draw, ->] (2.5,-3) -| (12, 0) |- (jump.340);
            \path[draw, thick, ->] (regdst) -| (5, -0.6) |- (jal.210);
            \path[draw, ->] (pc) -| (if);
            \path[draw, ->] (pc) -| (-4, 4) |- (jump);
            \path[draw, ->] (jump.160) -| (pc);
            \path[draw, ->] (jal) -- (writebuf);
            \path[draw, ->] (memread) -| (11, -1) |- (writebuf.15);
            \path[draw, dashed, ->] (writebuf.170) -| (reg.300);
            \path[draw, dashed, ->] (writebuf) -| (reg);
            \path[draw, dashed, ->, color=blue] (writebuf.190) -| (reg.240);

            \path[draw, ->, color=blue] (alucont) -- (alu);
            \path[draw, ->, color=blue] (cont.55) -| (jump.220);
            \path[draw, ->, color=blue] (cont.45) -| (jump.230);
            \path[draw, ->, color=blue] (cont.35) -| (jump.245);
            \path[draw, ->, color=blue] (cont.25) -| (11.5,0) |-
            (writebuf.345);
            \path[draw, ->, color=blue] (cont.15) -| (memread);
            \path[draw, ->, color=blue] (cont.5) -| (mem.55);
            \path[draw, ->, color=blue] (cont.355) -| (mem.125);
            \path[draw, ->, color=blue] (cont.345) -| (jal);
            \path[draw, ->, color=blue] (cont.335) -| (imm);
            \path[draw, ->, color=blue] (cont.325) -| (shmt);
            \path[draw, ->, color=blue] (cont.315) -| (1.5, 0.5) |-
            (alucont.160);
            \path[draw, ->, color=blue] (cont.250) -- (sign.128);
            \path[draw, ->, color=blue] (cont.240) -| (regdst);

            \node[block] (clock) at (-7, -5) {Clock};
            \path[draw, ->, thick, color=green] (clock) -- (if);
            \path[draw, ->, thick, color=green] (clock) -| (writebuf);
        \end{tikzpicture}
    }
    \caption{Full single cycle MIPS processor. The units with | indicate
    multiplexors. Black wires indicate data wires. Blue wires indicate control
    wires. Green wires indicate clock}
    \label{fig:full}
\end{figure}

\subsection{Larger MIPS programs}


%    \item[Jump] Controls whether or not the instruction is a jump instruction,
%        i.e. if the \texttt{PC} register should be changed.

%    \item[JAL] Contrals whether or not the instruction is a \texttt{jal}
%        instruction, i.e. that the \texttt{PC+4} address should be stored.

%    \item[LogicalImmediate] Controls whether or not the sign extender should
%        be a sign extender, in the case of a numeral immediate, or if it
%        should be a zero extender, in the case of a logical I-format
%        instruction.

%\subsection{Jump control}
%The jump control is the part of the processor, that based on the instruction
%changes the value of the PC register. There are two ways to jump: by branching
%and by jumping.
%
%\subsubsection*{Implementation}
%We start by implementing the control for the branching logic. We need to
%support 2 branch instructions in our basic processor: branch equal and branch
%not equal. Therefore we will need two signals: \texttt{Branch} and
%\texttt{BranchNot}. The \texttt{Branch} is used to indicate that the
%instruction should change the PC register. The \texttt{BranchNot} is used to
%choose whether or not the \texttt{Zero} flag from the ALU should be
%\texttt{1} or \texttt{0} for the instruction to branch. In both instructions,
%we compute the subtraction of the two input registers, and if the result is
%\texttt{1} they are equal, otherwise they are not equal. The \texttt{Zero}
%signal is then send to an \texttt{AND} gate along with the \texttt{Branch}
%signal.
%
%Then we need to implement the jump unit. This is a little bit easier, as we do
%not depend on anything from the ALU. The problem is that we need to change the
%decoder to accept a new format: the J-format. The J-format consists of an
%opcode, and a 26-bit address. The address is left shifted by 2, to ensure word
%alignment, and the upper 4 bits of the PC is added to the final address. We
%also need another control signal: \texttt{Jump}. We use this to multiplex
%between the newly computed address and the output from the previous mux (branch
%or pc+4).
%
%\subsubsection*{Testing}
%We test the jump unit by adding jump instructions in the program within the
%Instruction Memory.

%\subsection{Adding additional instructions}
%To add additional instructions, we need to add additional circuitry and entries
%in the \tt{enum}s. We will go through implementing the MIPS core instruction
%set.
%
%We start with the remaining R format instructions (Except for shifting,
%multiplication and division). This is straightforward, as we only need to add
%additional entries to the \tt{enum}s, add the additional cases in the
%\tt{switch} in the ALU control and in the \tt{switch} in the ALU.
%
%For shifting, we need to extract extra information from the instruction in the
%Splitter: the \tt{shamt} field. Following this, we add an additional control
%signal, and multiplex on whether it should be the value read from the registers
%or the \tt{shamt}, which should be the B input for the ALU.
%
%Then we have the remaining arithmetic I format instructions. This is also
%straightforward, as we only need to extend the \tt{enum}s, and add additional
%entries to the \tt{switch} in the ALU control.
%
%Next we need the \tt{jal} instruction. Here we need circuitry to store the
%contents of the \tt{PC} register. To do this, we send the \tt{PC} to the
%\tt{EX} stage, and multiplex on the output from the ALU and the \tt{PC}, with
%the \tt{JAL} control signal.
%
%Next we need the \tt{jr} instruction. We add an additional signal, and
%multiplex on the value read from register, and the normal \tt{PC+4}.
%
%Then we have the \tt{mult}, \tt{multu}, \tt{div} and \tt{divu} instructions.
%These are all R format, so we follow the same procedure. However, instead of
%sending the result on the ALU result bus, we store it in two additional
%registers, which we keep in the ALU: \tt{HI} and \tt{LO}. Following this, we
%can also easily add the instructions \tt{mfhi}, \tt{mflo}, \tt{mthi} and
%\tt{mtlo}, which moves data to and from the two new registers.
%
%Finally, we have the \tt{bne} instruction. We add an additional signal, and
%multiplex the \tt{NOT}ed \tt{zero} signal from the ALU as the signal for the
%branching \tt{AND} gate.
%
%\subsection{Test programs}
%Snak om at bruge MARS!
%
%Now that we have our single cycle MIPS processor, we are ready to throw actual
%instructions at it. We start by collecting all of the smaller test instructions
%into a full test program. SE APPENDIX! (og lav det for den sags skyld)
%
%Then we have a Quicksort written in MIPS assembly.
